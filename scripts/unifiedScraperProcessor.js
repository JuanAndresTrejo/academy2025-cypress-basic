const fs = require('fs').promises;
const path = require('path');
const glob = require('glob');

/**
 * ðŸš€ UNIFIED SCRAPER PROCESSOR - Script Integral Unificado
 * 
 * Este script combina TODA la funcionalidad necesaria para:
 * 1. ðŸ” Procesar archivos discovered generados por el scraper
 * 2. ðŸ“ Generar locators optimizados automÃ¡ticamente
 * 3. ðŸ—ï¸ Crear archivos .feature, steps y page objects
 * 4. ðŸ”§ Corregir imports y referencias problemÃ¡ticas
 * 5. ðŸŒ Aplicar traducciones completas
 * 6. âœ… Validar formato Gherkin
 * 7. ðŸ§¹ Limpiar y optimizar archivos generados
 * 8. ðŸ“Š Generar reportes y estadÃ­sticas
 */

// ============================================================================
// CONFIGURACIÃ“N Y CONSTANTES
// ============================================================================
const CONFIG = {
    baseDir: path.join(__dirname, '..'),
    discoveredDir: 'cypress/fixtures/discovered',
    locatorsDir: 'cypress/pages/locators',
    featuresDir: 'cypress/e2e/features',
    stepsDir: 'cypress/e2e/step_definitions',
    pagesDir: 'cypress/pages',
    outputFile: 'AutoGeneratedLocators.json',
    usageExampleFile: 'UsageExample.js',
    reportFile: 'ProcessingReport.json'
};

// ============================================================================
// CLASE PRINCIPAL DEL PROCESADOR UNIFICADO
// ============================================================================
class UnifiedScraperProcessor {
    constructor() {
        this.stats = {
            startTime: new Date(),
            filesProcessed: 0,
            locatorsGenerated: 0,
            featuresCreated: 0,
            stepsCreated: 0,
            pageObjectsCreated: 0,
            errorsFound: 0,
            warnings: []
        };
        
        this.existingSteps = new Map();
        this.existingPageObjects = new Map();
        this.generatedLocators = {};
    }

    // ========================================================================
    // MÃ‰TODO PRINCIPAL - EJECUTA TODO EL PROCESO
    // ========================================================================
    async processAll() {
        try {
            console.log('ðŸš€ INICIANDO PROCESAMIENTO UNIFICADO DEL SCRAPER...\n');
            
            // 1. Verificar estructura de directorios
            await this.ensureDirectoryStructure();
            
            // 2. Escanear archivos existentes
            await this.scanExistingFiles();
            
            // 3. Procesar archivos discovered
            const discoveredData = await this.processDiscoveredFiles();
            
            // 4. Generar locators optimizados
            await this.generateOptimizedLocators(discoveredData);
            
            // 5. Crear archivos de ejemplo y documentaciÃ³n
            await this.generateUsageExamples();
            
            // 6. Generar features y steps automÃ¡ticamente
            await this.generateTestFiles();
            
            // 7. Corregir imports y referencias
            await this.fixImportsAndReferences();
            
            // 8. Validar archivos generados
            await this.validateGeneratedFiles();
            
            // 9. Generar reporte final
            await this.generateFinalReport();
            
            console.log('\nâœ… PROCESAMIENTO UNIFICADO COMPLETADO EXITOSAMENTE!');
            
        } catch (error) {
            console.error('âŒ Error en el procesamiento unificado:', error);
            this.stats.errorsFound++;
            throw error;
        }
    }

    // ========================================================================
    // VERIFICAR Y CREAR ESTRUCTURA DE DIRECTORIOS
    // ========================================================================
    async ensureDirectoryStructure() {
        console.log('ðŸ“ Verificando estructura de directorios...');
        
        const directories = [
            path.join(CONFIG.baseDir, CONFIG.discoveredDir),
            path.join(CONFIG.baseDir, CONFIG.locatorsDir),
            path.join(CONFIG.baseDir, CONFIG.featuresDir),
            path.join(CONFIG.baseDir, CONFIG.stepsDir),
            path.join(CONFIG.baseDir, CONFIG.pagesDir)
        ];
        
        for (const dir of directories) {
            try {
                await fs.access(dir);
                console.log(`   âœ… ${path.relative(CONFIG.baseDir, dir)}`);
            } catch (error) {
                await fs.mkdir(dir, { recursive: true });
                console.log(`   ðŸ“ Creado: ${path.relative(CONFIG.baseDir, dir)}`);
            }
        }
    }

    // ========================================================================
    // ESCANEAR ARCHIVOS EXISTENTES
    // ========================================================================
    async scanExistingFiles() {
        console.log('\nðŸ” Escaneando archivos existentes...');
        
        // Escanear steps existentes
        await this.scanExistingSteps();
        
        // Escanear page objects existentes
        await this.scanExistingPageObjects();
        
        console.log(`   ðŸ“Š Steps encontrados: ${this.existingSteps.size}`);
        console.log(`   ðŸ“Š Page Objects encontrados: ${this.existingPageObjects.size}`);
    }

    async scanExistingSteps() {
        const stepsDir = path.join(CONFIG.baseDir, CONFIG.stepsDir);
        try {
            const files = await fs.readdir(stepsDir);
            const jsFiles = files.filter(file => file.endsWith('.js'));
            
            for (const file of jsFiles) {
                const filePath = path.join(stepsDir, file);
                const content = await fs.readFile(filePath, 'utf8');
                this.extractStepsFromContent(content, file);
            }
        } catch (error) {
            console.log('âš ï¸ No se encontraron steps existentes');
        }
    }

    async scanExistingPageObjects() {
        const pagesDir = path.join(CONFIG.baseDir, CONFIG.pagesDir);
        try {
            const files = await fs.readdir(pagesDir);
            const jsFiles = files.filter(file => file.endsWith('.js'));
            
            for (const file of jsFiles) {
                const filePath = path.join(pagesDir, file);
                const content = await fs.readFile(filePath, 'utf8');
                this.extractPageObjectInfo(content, file);
            }
        } catch (error) {
            console.log('âš ï¸ No se encontraron page objects existentes');
        }
    }

    extractStepsFromContent(content, fileName) {
        const stepRegex = /(Given|When|Then|And)\s*\(\s*['"`]([^'"`]+)['"`]/g;
        let match;
        
        while ((match = stepRegex.exec(content)) !== null) {
            const stepType = match[1];
            const stepText = match[2];
            const stepKey = this.normalizeStepText(stepText);
            
            if (!this.existingSteps.has(stepKey)) {
                this.existingSteps.set(stepKey, {
                    type: stepType,
                    text: stepText,
                    file: fileName
                });
            }
        }
    }

    extractPageObjectInfo(content, fileName) {
        const className = fileName.replace('.js', '');
        const methods = [];
        
        const methodRegex = /(\w+)\s*[=:]\s*\([^)]*\)\s*=>\s*{|(\w+)\s*\([^)]*\)\s*{/g;
        let match;
        
        while ((match = methodRegex.exec(content)) !== null) {
            const methodName = match[1] || match[2];
            if (methodName && !['constructor', 'elements'].includes(methodName)) {
                methods.push(methodName);
            }
        }

        this.existingPageObjects.set(className, {
            file: fileName,
            methods: methods
        });
    }

    normalizeStepText(text) {
        return text
            .toLowerCase()
            .replace(/\{[^}]+\}/g, '{param}')
            .replace(/[^\w\s]/g, '')
            .replace(/\s+/g, ' ')
            .trim();
    }

    // ========================================================================
    // PROCESAR ARCHIVOS DISCOVERED
    // ========================================================================
    async processDiscoveredFiles() {
        console.log('\nðŸ” Procesando archivos discovered...');
        
        const discoveredDir = path.join(CONFIG.baseDir, CONFIG.discoveredDir);
        console.log(`ðŸ” Buscando en directorio: ${discoveredDir}`);
        
        // Buscar archivos de elementos descubiertos - usar patrÃ³n relativo para Windows
        const searchPattern = CONFIG.discoveredDir + '/discovered-elements-*.json';
        console.log(`ðŸ” PatrÃ³n de bÃºsqueda: ${searchPattern}`);
        
        const elementFiles = glob.sync(searchPattern, { cwd: CONFIG.baseDir });
        const navigationFile = path.join(discoveredDir, 'navigation-map.json');
        const networkFile = path.join(discoveredDir, 'network-requests.json');
        
        console.log(`ðŸ“ Archivos de elementos encontrados: ${elementFiles.length}`);
        elementFiles.forEach(file => console.log(`   - ${path.basename(file)}`));
        
        // Convertir rutas relativas a absolutas
        const absoluteElementFiles = elementFiles.map(file => path.join(CONFIG.baseDir, file));
        
        if (absoluteElementFiles.length === 0) {
            throw new Error('No se encontraron archivos de elementos descubiertos');
        }
        
        // Usar el archivo mÃ¡s reciente
        const latestElementFile = absoluteElementFiles
            .map(file => ({
                path: file,
                mtime: require('fs').statSync(file).mtime
            }))
            .sort((a, b) => b.mtime - a.mtime)[0].path;
        
        console.log(`ðŸ“„ Procesando archivo: ${path.basename(latestElementFile)}`);
        this.stats.filesProcessed++;
        
        // Leer datos de elementos
        const elementsData = JSON.parse(await fs.readFile(latestElementFile, 'utf8'));
        
        // Leer datos de navegaciÃ³n si existe
        let navigationData = null;
        try {
            navigationData = JSON.parse(await fs.readFile(navigationFile, 'utf8'));
            console.log('ðŸ“ Archivo de navegaciÃ³n encontrado');
            this.stats.filesProcessed++;
        } catch (error) {
            console.log('âš ï¸ No se encontrÃ³ archivo de navegaciÃ³n');
        }
        
        // Leer datos de red si existe
        let networkData = null;
        try {
            networkData = JSON.parse(await fs.readFile(networkFile, 'utf8'));
            console.log('ðŸŒ Archivo de requests de red encontrado');
            this.stats.filesProcessed++;
        } catch (error) {
            console.log('âš ï¸ No se encontrÃ³ archivo de requests de red');
        }
        
        return {
            elements: elementsData,
            navigation: navigationData,
            network: networkData,
            sourceFile: path.basename(latestElementFile)
        };
    }

    // ========================================================================
    // GENERAR LOCATORS OPTIMIZADOS
    // ========================================================================
    async generateOptimizedLocators(discoveredData) {
        console.log('\nðŸ“ Generando locators optimizados...');
        
        const { elements, navigation } = discoveredData;
        
        // Crear estructura de locators optimizados
        this.generatedLocators = {
            metadata: {
                generatedAt: new Date().toISOString(),
                sourceFile: discoveredData.sourceFile,
                url: elements.metadata?.url || 'N/A',
                totalElementsProcessed: elements.metadata?.totalElements || 0,
                description: 'Locators generados automÃ¡ticamente por scraper inteligente unificado',
                processingStats: {
                    navigation: 0,
                    buttons: 0,
                    inputs: 0,
                    links: 0,
                    containers: 0,
                    images: 0,
                    interactive: 0
                }
            },
            navigation: {},
            buttons: {},
            inputs: {},
            links: {},
            containers: {},
            images: {},
            interactive: {}
        };
        
        // Procesar cada categorÃ­a de elementos
        await this.processElementCategory('navigation', elements.navigation);
        await this.processElementCategory('buttons', elements.buttons);
        await this.processElementCategory('inputs', elements.inputs);
        await this.processElementCategory('links', elements.links);
        await this.processElementCategory('containers', elements.containers);
        await this.processElementCategory('images', elements.images);
        await this.processElementCategory('interactive', elements.interactive);
        
        // Agregar elementos de navegaciÃ³n desde navigation-map.json si existe
        if (navigation && navigation.navigationElements) {
            console.log(`ðŸ§­ Agregando ${navigation.navigationElements.length} elementos de navegaciÃ³n adicionales...`);
            
            navigation.navigationElements.forEach(element => {
                const key = this.generateKey({ text: element.text });
                
                if (key && key.length > 0 && !this.generatedLocators.navigation[key]) {
                    this.generatedLocators.navigation[key] = {
                        primary: element.selectors[0] || '',
                        alternatives: element.selectors.slice(1, 3),
                        text: element.text,
                        href: element.href,
                        tag: element.tag,
                        description: `NavegaciÃ³n: ${element.text}`,
                        isInteractive: true,
                        source: 'navigation-map'
                    };
                    this.generatedLocators.metadata.processingStats.navigation++;
                }
            });
        }
        
        // Guardar locators optimizados
        const outputPath = path.join(CONFIG.baseDir, CONFIG.locatorsDir, CONFIG.outputFile);
        await fs.writeFile(outputPath, JSON.stringify(this.generatedLocators, null, 2));
        
        // Calcular estadÃ­sticas
        const totalLocators = Object.values(this.generatedLocators.metadata.processingStats)
            .reduce((sum, count) => sum + count, 0);
        
        this.stats.locatorsGenerated = totalLocators;
        
        console.log(`ðŸ“Š Locators generados: ${totalLocators}`);
        Object.entries(this.generatedLocators.metadata.processingStats).forEach(([category, count]) => {
            if (count > 0) {
                console.log(`   â€¢ ${category}: ${count}`);
            }
        });
        
        console.log(`ðŸ’¾ Guardado en: ${path.relative(CONFIG.baseDir, outputPath)}`);
    }

    async processElementCategory(categoryName, elements) {
        if (!elements || elements.length === 0) {
            return;
        }
        
        console.log(`${this.getCategoryIcon(categoryName)} Procesando ${elements.length} ${categoryName}...`);
        
        elements.forEach(element => {
            const key = this.generateKey(element);
            if (key && key.length > 0) {
                this.generatedLocators[categoryName][key] = this.createLocatorObject(element, categoryName);
                this.generatedLocators.metadata.processingStats[categoryName]++;
            }
        });
    }

    getCategoryIcon(category) {
        const icons = {
            navigation: 'ðŸ§­',
            buttons: 'ðŸ”˜',
            inputs: 'ðŸ“',
            links: 'ðŸ”—',
            containers: 'ðŸ“¦',
            images: 'ðŸ–¼ï¸',
            interactive: 'âš¡'
        };
        return icons[category] || 'ðŸ“„';
    }

    createLocatorObject(element, category) {
        const baseObject = {
            primary: this.getBestSelector(element.selectors),
            alternatives: element.selectors.slice(1, 3),
            description: this.generateDescription(element, category),
            isInteractive: element.isInteractive,
            position: element.position
        };

        // Agregar propiedades especÃ­ficas por categorÃ­a
        switch (category) {
            case 'navigation':
            case 'links':
                return {
                    ...baseObject,
                    text: element.text?.substring(0, 50) || '',
                    href: element.attributes?.href || '',
                    tag: element.tag
                };
            
            case 'buttons':
                return {
                    ...baseObject,
                    text: element.text?.substring(0, 50) || '',
                    type: element.attributes?.type || 'button'
                };
            
            case 'inputs':
                return {
                    ...baseObject,
                    name: element.attributes?.name || '',
                    type: element.attributes?.type || 'text',
                    placeholder: element.attributes?.placeholder || ''
                };
            
            case 'images':
                return {
                    ...baseObject,
                    src: element.attributes?.src || '',
                    alt: element.attributes?.alt || ''
                };
            
            case 'containers':
                return {
                    ...baseObject,
                    tag: element.tag
                };
            
            default:
                return baseObject;
        }
    }

    generateKey(element) {
        if (element.attributes?.id) {
            return element.attributes.id.toLowerCase().replace(/[^a-z0-9]/g, '_');
        }
        
        if (element.text && element.text.length > 0 && element.text.length < 30) {
            return element.text.toLowerCase()
                .replace(/[^a-z0-9\s]/g, '')
                .replace(/\s+/g, '_')
                .replace(/^_+|_+$/g, '');
        }
        
        if (element.attributes?.class) {
            const firstClass = element.attributes.class.split(' ')[0];
            return firstClass.toLowerCase().replace(/[^a-z0-9]/g, '_');
        }
        
        return `${element.tag}_${element.id}`;
    }

    getBestSelector(selectors) {
        if (!selectors || selectors.length === 0) return '';
        
        // Prioridad: ID > data-testid > class especÃ­fica > otros
        for (const selector of selectors) {
            if (selector.startsWith('#')) return selector;
            if (selector.includes('data-testid')) return selector;
            if (selector.startsWith('.') && !selector.includes(' ')) return selector;
        }
        return selectors[0] || '';
    }

    generateDescription(element, category) {
        const categoryNames = {
            navigation: 'NavegaciÃ³n',
            buttons: 'BotÃ³n',
            inputs: 'Input',
            links: 'Enlace',
            containers: 'Contenedor',
            images: 'Imagen',
            interactive: 'Elemento interactivo'
        };
        
        const categoryName = categoryNames[category] || 'Elemento';
        const identifier = element.text || element.attributes?.id || element.attributes?.name || 'Sin identificador';
        
        return `${categoryName}: ${identifier}`;
    }

    // ========================================================================
    // GENERAR EJEMPLOS DE USO Y DOCUMENTACIÃ“N
    // ========================================================================
    async generateUsageExamples() {
        console.log('\nðŸ“š Generando ejemplos de uso...');
        
        const usageExample = this.createUsageExampleContent();
        const usageExamplePath = path.join(CONFIG.baseDir, CONFIG.locatorsDir, CONFIG.usageExampleFile);
        
        await fs.writeFile(usageExamplePath, usageExample);
        console.log(`ðŸ“ Ejemplo de uso guardado en: ${path.relative(CONFIG.baseDir, usageExamplePath)}`);
    }

    createUsageExampleContent() {
        return `/**
 * ðŸ“š EJEMPLO DE USO DE LOCATORS AUTO-GENERADOS
 * 
 * Este archivo muestra cÃ³mo usar los locators generados automÃ¡ticamente
 * por el sistema de scraper inteligente unificado.
 * 
 * Generado automÃ¡ticamente el: ${new Date().toISOString()}
 */

// Importar locators
const locators = require('./AutoGeneratedLocators.json');

// ============================================================================
// EJEMPLOS DE USO EN CYPRESS
// ============================================================================

class AutoGeneratedPage {
    
    // Ejemplo: Usar locators de navegaciÃ³n
    clickNavigationItem(itemKey) {
        const navItem = locators.navigation[itemKey];
        if (navItem) {
            cy.get(navItem.primary).click();
        } else {
            throw new Error(\`Elemento de navegaciÃ³n '\${itemKey}' no encontrado\`);
        }
    }
    
    // Ejemplo: Usar locators de botones con fallback
    clickButton(buttonKey) {
        const button = locators.buttons[buttonKey];
        if (button) {
            // Intentar selector principal
            cy.get('body').then($body => {
                if ($body.find(button.primary).length > 0) {
                    cy.get(button.primary).click();
                } else if (button.alternatives && button.alternatives.length > 0) {
                    // Usar selector alternativo
                    cy.get(button.alternatives[0]).click();
                } else {
                    throw new Error(\`BotÃ³n '\${buttonKey}' no encontrado\`);
                }
            });
        }
    }
    
    // Ejemplo: Llenar inputs automÃ¡ticamente
    fillInput(inputKey, value) {
        const input = locators.inputs[inputKey];
        if (input) {
            cy.get(input.primary).clear().type(value);
        } else {
            throw new Error(\`Input '\${inputKey}' no encontrado\`);
        }
    }
    
    // Ejemplo: Verificar elementos
    verifyElementExists(category, elementKey) {
        const element = locators[category] && locators[category][elementKey];
        if (element) {
            cy.get(element.primary).should('exist').and('be.visible');
        } else {
            throw new Error(\`Elemento '\${elementKey}' en categorÃ­a '\${category}' no encontrado\`);
        }
    }
    
    // Ejemplo: Obtener informaciÃ³n de elemento
    getElementInfo(category, elementKey) {
        const element = locators[category] && locators[category][elementKey];
        if (element) {
            return {
                selector: element.primary,
                alternatives: element.alternatives,
                description: element.description,
                isInteractive: element.isInteractive
            };
        }
        return null;
    }
}

// ============================================================================
// EJEMPLOS DE USO EN STEPS
// ============================================================================

// Ejemplo en step definition
/*
When('Hago click en el elemento {string} de {string}', (elementKey, category) => {
    const page = new AutoGeneratedPage();
    
    switch(category) {
        case 'navegacion':
            page.clickNavigationItem(elementKey);
            break;
        case 'botones':
            page.clickButton(elementKey);
            break;
        default:
            page.verifyElementExists(category, elementKey);
    }
});
*/

// ============================================================================
// UTILIDADES PARA DEBUGGING
// ============================================================================

class LocatorUtils {
    
    // Listar todos los locators disponibles
    static listAllLocators() {
        console.log('ðŸ“‹ Locators disponibles:');
        Object.entries(locators).forEach(([category, items]) => {
            if (category !== 'metadata' && typeof items === 'object') {
                console.log(\`\\n\${category.toUpperCase()}:\`);
                Object.keys(items).forEach(key => {
                    console.log(\`  - \${key}\`);
                });
            }
        });
    }
    
    // Buscar locator por texto
    static findLocatorByText(searchText) {
        const results = [];
        Object.entries(locators).forEach(([category, items]) => {
            if (category !== 'metadata' && typeof items === 'object') {
                Object.entries(items).forEach(([key, locator]) => {
                    if (locator.text && locator.text.toLowerCase().includes(searchText.toLowerCase())) {
                        results.push({
                            category,
                            key,
                            locator
                        });
                    }
                });
            }
        });
        return results;
    }
    
    // Validar que un locator existe en la pÃ¡gina
    static validateLocator(category, key) {
        const element = locators[category] && locators[category][key];
        if (!element) {
            return { valid: false, error: 'Locator no encontrado' };
        }
        
        return cy.get('body').then($body => {
            const primaryExists = $body.find(element.primary).length > 0;
            const alternativeExists = element.alternatives && 
                element.alternatives.some(alt => $body.find(alt).length > 0);
            
            return {
                valid: primaryExists || alternativeExists,
                primaryExists,
                alternativeExists,
                element
            };
        });
    }
}

module.exports = { AutoGeneratedPage, LocatorUtils };

// ============================================================================
// ESTADÃSTICAS DE GENERACIÃ“N
// ============================================================================
/*
Metadata de generaciÃ³n:
${JSON.stringify(this.generatedLocators.metadata, null, 2)}
*/
`;
    }

    // ========================================================================
    // GENERAR ARCHIVOS DE PRUEBA AUTOMÃTICAMENTE
    // ========================================================================
    async generateTestFiles() {
        console.log('\nðŸ—ï¸ Generando archivos de prueba automÃ¡ticamente...');
        
        // Generar feature file basado en locators
        await this.generateFeatureFile();
        
        // Generar steps basados en locators
        await this.generateStepsFile();
        
        // Generar page object basado en locators
        await this.generatePageObjectFile();
        
        // Generar casuÃ­stica avanzada basada en datos extraÃ­dos
        await this.generateAdvancedTestCases();
    }

    async generateFeatureFile() {
        const featureContent = `# language: es
@scraper-auto-generated
CaracterÃ­stica: Pruebas automÃ¡ticas generadas por scraper
  Como usuario del sistema
  Quiero poder interactuar con todos los elementos detectados
  Para verificar que la aplicaciÃ³n funciona correctamente

  Antecedentes:
    Dado que navego al sitio web
    Y espero que la pÃ¡gina estÃ© cargada

  @navegacion
  Escenario: Verificar elementos de navegaciÃ³n
    Cuando verifico que existen los elementos de navegaciÃ³n
    Entonces todos los elementos de navegaciÃ³n deben estar visibles

  @botones
  Escenario: Verificar botones interactivos
    Cuando verifico que existen los botones
    Entonces todos los botones deben ser clickeables

  @formularios
  Escenario: Verificar campos de entrada
    Cuando verifico que existen los campos de entrada
    Entonces todos los campos deben permitir entrada de texto

  @enlaces
  Escenario: Verificar enlaces
    Cuando verifico que existen los enlaces
    Entonces todos los enlaces deben tener destinos vÃ¡lidos
`;

        const featurePath = path.join(CONFIG.baseDir, CONFIG.featuresDir, 'auto-generated-scraper.feature');
        await fs.writeFile(featurePath, featureContent);
        this.stats.featuresCreated++;
        console.log(`ðŸ“„ Feature generado: ${path.relative(CONFIG.baseDir, featurePath)}`);
    }

    async generateStepsFile() {
        const stepsContent = `import { Given, When, Then } from "@badeball/cypress-cucumber-preprocessor";

/**
 * ðŸ¤– STEPS AUTO-GENERADOS POR SCRAPER
 * Generado automÃ¡ticamente el: ${new Date().toISOString()}
 */

// Importar locators directamente
const locators = require("../../pages/locators/AutoGeneratedLocators.json");

Given('que navego al sitio web', () => {
    cy.visit('/');
});

Given('espero que la pÃ¡gina estÃ© cargada', () => {
    cy.get('body').should('be.visible');
    cy.wait(2000);
});

When('verifico que existen los elementos de navegaciÃ³n', () => {
    const navElements = Object.keys(locators.navigation);
    cy.log(\`ðŸ§­ Verificando \${navElements.length} elementos de navegaciÃ³n\`);
    
    navElements.forEach(elementKey => {
        const element = locators.navigation[elementKey];
        if (element && element.primary) {
            cy.get(element.primary).should('exist');
        }
    });
});

When('verifico que existen los botones', () => {
    const buttonElements = Object.keys(locators.buttons);
    cy.log(\`ðŸ”˜ Verificando \${buttonElements.length} botones\`);
    
    buttonElements.forEach(elementKey => {
        const element = locators.buttons[elementKey];
        if (element && element.primary) {
            cy.get(element.primary).should('exist');
        }
    });
});

When('verifico que existen los campos de entrada', () => {
    const inputElements = Object.keys(locators.inputs);
    cy.log(\`ðŸ“ Verificando \${inputElements.length} campos de entrada\`);
    
    inputElements.forEach(elementKey => {
        const element = locators.inputs[elementKey];
        if (element && element.primary) {
            cy.get(element.primary).should('exist');
        }
    });
});

When('verifico que existen los enlaces', () => {
    const linkElements = Object.keys(locators.links);
    cy.log(\`ðŸ”— Verificando \${linkElements.length} enlaces\`);
    
    linkElements.forEach(elementKey => {
        const element = locators.links[elementKey];
        if (element && element.primary) {
            cy.get(element.primary).should('exist');
        }
    });
});

Then('todos los elementos de navegaciÃ³n deben estar visibles', () => {
    cy.log('âœ… Todos los elementos de navegaciÃ³n verificados');
});

Then('todos los botones deben ser clickeables', () => {
    cy.log('âœ… Todos los botones verificados');
});

Then('todos los campos deben permitir entrada de texto', () => {
    cy.log('âœ… Todos los campos de entrada verificados');
});

Then('todos los enlaces deben tener destinos vÃ¡lidos', () => {
    cy.log('âœ… Todos los enlaces verificados');
});

// Steps dinÃ¡micos para interactuar con elementos especÃ­ficos
When('hago click en el elemento {string} de categorÃ­a {string}', (elementKey, category) => {
    const element = locators[category] && locators[category][elementKey];
    if (element && element.primary) {
        cy.get(element.primary).click();
    } else {
        throw new Error(\`Elemento '\${elementKey}' no encontrado en categorÃ­a '\${category}'\`);
    }
});

When('lleno el campo {string} con {string}', (inputKey, value) => {
    const element = locators.inputs && locators.inputs[inputKey];
    if (element && element.primary) {
        cy.get(element.primary).clear().type(value);
    } else {
        throw new Error(\`Campo '\${inputKey}' no encontrado\`);
    }
});

Then('el elemento {string} de {string} debe existir', (elementKey, category) => {
    const element = locators[category] && locators[category][elementKey];
    if (element && element.primary) {
        cy.get(element.primary).should('exist').and('be.visible');
    } else {
        throw new Error(\`Elemento '\${elementKey}' no encontrado en categorÃ­a '\${category}'\`);
    }
});
`;

        const stepsPath = path.join(CONFIG.baseDir, CONFIG.stepsDir, 'autoGeneratedScraperSteps.js');
        await fs.writeFile(stepsPath, stepsContent);
        this.stats.stepsCreated++;
        console.log(`ðŸ“„ Steps generados: ${path.relative(CONFIG.baseDir, stepsPath)}`);
    }

    async generatePageObjectFile() {
        const pageObjectContent = `/**
 * ðŸ¤– PAGE OBJECT AUTO-GENERADO POR SCRAPER
 * Generado automÃ¡ticamente el: ${new Date().toISOString()}
 */

const locators = require("./locators/AutoGeneratedLocators.json");

class AutoGeneratedScraperPage {
    
    constructor() {
        this.locators = locators;
    }
    
    // ========================================================================
    // MÃ‰TODOS DE NAVEGACIÃ“N
    // ========================================================================
    ${this.generateNavigationMethods()}
    
    // ========================================================================
    // MÃ‰TODOS DE BOTONES
    // ========================================================================
    ${this.generateButtonMethods()}
    
    // ========================================================================
    // MÃ‰TODOS DE INPUTS
    // ========================================================================
    ${this.generateInputMethods()}
    
    // ========================================================================
    // MÃ‰TODOS DE ENLACES
    // ========================================================================
    ${this.generateLinkMethods()}
    
    // ========================================================================
    // MÃ‰TODOS GENÃ‰RICOS
    // ========================================================================
    
    getElement(category, elementKey) {
        const element = this.locators[category] && this.locators[category][elementKey];
        if (!element) {
            throw new Error(\`Elemento '\${elementKey}' no encontrado en categorÃ­a '\${category}'\`);
        }
        return cy.get(element.primary);
    }
    
    verifyElementExists(category, elementKey) {
        const element = this.locators[category] && this.locators[category][elementKey];
        if (element) {
            return cy.get(element.primary).should('exist').and('be.visible');
        }
        throw new Error(\`Elemento '\${elementKey}' no encontrado en categorÃ­a '\${category}'\`);
    }
    
    getAllElementsInCategory(category) {
        return Object.keys(this.locators[category] || {});
    }
    
    getElementInfo(category, elementKey) {
        return this.locators[category] && this.locators[category][elementKey];
    }
}

module.exports = AutoGeneratedScraperPage;
`;

        const pageObjectPath = path.join(CONFIG.baseDir, CONFIG.pagesDir, 'AutoGeneratedScraperPage.js');
        await fs.writeFile(pageObjectPath, pageObjectContent);
        this.stats.pageObjectsCreated++;
        console.log(`ðŸ“„ Page Object generado: ${path.relative(CONFIG.baseDir, pageObjectPath)}`);
    }

    generateNavigationMethods() {
        if (!this.generatedLocators.navigation) return '';
        
        const methods = Object.keys(this.generatedLocators.navigation).map(key => {
            const element = this.generatedLocators.navigation[key];
            const methodName = `click${key.charAt(0).toUpperCase() + key.slice(1)}`;
            
            return `    ${methodName}() {
        // ${element.description}
        return cy.get('${element.primary}').click();
    }`;
        });
        
        return methods.join('\n\n');
    }

    generateButtonMethods() {
        if (!this.generatedLocators.buttons) return '';
        
        const methods = Object.keys(this.generatedLocators.buttons).map(key => {
            const element = this.generatedLocators.buttons[key];
            const methodName = `click${key.charAt(0).toUpperCase() + key.slice(1)}Button`;
            
            return `    ${methodName}() {
        // ${element.description}
        return cy.get('${element.primary}').click();
    }`;
        });
        
        return methods.join('\n\n');
    }

    generateInputMethods() {
        if (!this.generatedLocators.inputs) return '';
        
        const methods = Object.keys(this.generatedLocators.inputs).map(key => {
            const element = this.generatedLocators.inputs[key];
            const methodName = `fill${key.charAt(0).toUpperCase() + key.slice(1)}`;
            
            return `    ${methodName}(value) {
        // ${element.description}
        return cy.get('${element.primary}').clear().type(value);
    }`;
        });
        
        return methods.join('\n\n');
    }

    generateLinkMethods() {
        if (!this.generatedLocators.links) return '';
        
        const methods = Object.keys(this.generatedLocators.links).map(key => {
            const element = this.generatedLocators.links[key];
            const methodName = `click${key.charAt(0).toUpperCase() + key.slice(1)}Link`;
            
            return `    ${methodName}() {
        // ${element.description}
        return cy.get('${element.primary}').click();
    }`;
        });
        
        return methods.join('\n\n');
    }

    // ========================================================================
    // GENERAR CASUÃSTICA AVANZADA
    // ========================================================================
    async generateAdvancedTestCases() {
        console.log('\nðŸŽ¯ Generando casuÃ­stica avanzada...');
        
        // Leer datos de casos de prueba si existen
        const casosPath = path.join(CONFIG.baseDir, 'cypress/fixtures/casos_prueba.json');
        let casosData = null;
        
        try {
            casosData = JSON.parse(await fs.readFile(casosPath, 'utf8'));
            if (Object.keys(casosData).length === 0) {
                console.log('âš ï¸ No hay datos de casos de prueba, generando casuÃ­stica basada en locators');
                await this.generateLocatorBasedTestCases();
                return;
            }
        } catch (error) {
            console.log('âš ï¸ No se encontrÃ³ archivo de casos de prueba, generando casuÃ­stica basada en locators');
            await this.generateLocatorBasedTestCases();
            return;
        }
        
        console.log(`ðŸ“Š Procesando ${Object.keys(casosData).length} secciones de casos de prueba`);
        
        // Generar features especÃ­ficos por secciÃ³n
        for (const [seccion, casos] of Object.entries(casosData)) {
            if (casos && casos.length > 0) {
                await this.generateSectionFeature(seccion, casos);
                await this.generateSectionSteps(seccion, casos);
                await this.generateSectionPageObject(seccion, casos);
            }
        }
        
        // Generar feature maestro que incluya todas las secciones
        await this.generateMasterFeature(casosData);
        
        console.log('âœ… CasuÃ­stica avanzada generada exitosamente');
    }

    async generateLocatorBasedTestCases() {
        console.log('ðŸ”§ Generando casuÃ­stica basada en locators disponibles...');
        
        const categories = Object.keys(this.generatedLocators).filter(key => 
            key !== 'metadata' && Object.keys(this.generatedLocators[key]).length > 0
        );
        
        // Generar feature basado en categorÃ­as de locators
        const featureContent = `# language: es
@locator-based @auto-generated
CaracterÃ­stica: Pruebas automÃ¡ticas basadas en elementos detectados
  Como usuario del sistema
  Quiero poder interactuar con todos los elementos detectados automÃ¡ticamente
  Para verificar que la aplicaciÃ³n funciona correctamente

  Antecedentes:
    Dado que navego al sitio web
    Y espero que la pÃ¡gina estÃ© cargada

${categories.map(category => this.generateCategoryScenarios(category)).join('\n\n')}

  @comprehensive
  Escenario: VerificaciÃ³n completa de todos los elementos
    Cuando verifico todos los elementos de navegaciÃ³n
    Y verifico todos los botones interactivos
    Y verifico todos los campos de entrada
    Y verifico todos los enlaces
    Entonces todos los elementos deben estar funcionales
`;

        const featurePath = path.join(CONFIG.baseDir, CONFIG.featuresDir, 'comprehensive-locator-tests.feature');
        await fs.writeFile(featurePath, featureContent);
        console.log(`ðŸ“„ Feature comprehensivo generado: ${path.relative(CONFIG.baseDir, featurePath)}`);
        
        // Generar steps comprehensivos
        await this.generateComprehensiveSteps();
    }

    generateCategoryScenarios(category) {
        const categoryNames = {
            navigation: 'navegaciÃ³n',
            buttons: 'botones',
            inputs: 'campos de entrada',
            links: 'enlaces',
            containers: 'contenedores',
            images: 'imÃ¡genes',
            interactive: 'elementos interactivos'
        };
        
        const categoryName = categoryNames[category] || category;
        const elements = Object.keys(this.generatedLocators[category]);
        
        return `  @${category}
  Escenario: Verificar elementos de ${categoryName}
    Cuando verifico que existen los elementos de ${categoryName}
    Entonces todos los elementos de ${categoryName} deben estar visibles
    Y debo poder interactuar con ${elements.length} elementos de ${categoryName}`;
    }

    async generateComprehensiveSteps() {
        const stepsContent = `import { Given, When, Then } from "@badeball/cypress-cucumber-preprocessor";

/**
 * ðŸŽ¯ STEPS COMPREHENSIVOS AUTO-GENERADOS
 * Generado automÃ¡ticamente el: ${new Date().toISOString()}
 */

const locators = require("../../pages/locators/AutoGeneratedLocators.json");

// Steps para verificaciÃ³n completa
When('verifico todos los elementos de navegaciÃ³n', () => {
    const elements = Object.keys(locators.navigation || {});
    cy.log(\`ðŸ§­ Verificando \${elements.length} elementos de navegaciÃ³n\`);
    
    elements.forEach(key => {
        const element = locators.navigation[key];
        if (element && element.primary) {
            cy.get(element.primary).should('exist');
        }
    });
});

When('verifico todos los botones interactivos', () => {
    const elements = Object.keys(locators.buttons || {});
    cy.log(\`ðŸ”˜ Verificando \${elements.length} botones\`);
    
    elements.forEach(key => {
        const element = locators.buttons[key];
        if (element && element.primary) {
            cy.get(element.primary).should('exist');
        }
    });
});

When('verifico todos los campos de entrada', () => {
    const elements = Object.keys(locators.inputs || {});
    cy.log(\`ðŸ“ Verificando \${elements.length} campos de entrada\`);
    
    elements.forEach(key => {
        const element = locators.inputs[key];
        if (element && element.primary) {
            cy.get(element.primary).should('exist');
        }
    });
});

When('verifico todos los enlaces', () => {
    const elements = Object.keys(locators.links || {});
    cy.log(\`ðŸ”— Verificando \${elements.length} enlaces\`);
    
    elements.forEach(key => {
        const element = locators.links[key];
        if (element && element.primary) {
            cy.get(element.primary).should('exist');
        }
    });
});

Then('todos los elementos deben estar funcionales', () => {
    cy.log('âœ… VerificaciÃ³n completa de elementos finalizada');
});

// Steps dinÃ¡micos por categorÃ­a
${Object.keys(this.generatedLocators).filter(key => key !== 'metadata').map(category => {
    const categoryName = category === 'navigation' ? 'navegaciÃ³n' : 
                        category === 'buttons' ? 'botones' :
                        category === 'inputs' ? 'campos de entrada' :
                        category === 'links' ? 'enlaces' :
                        category === 'containers' ? 'contenedores' :
                        category === 'images' ? 'imÃ¡genes' :
                        category === 'interactive' ? 'elementos interactivos' : category;
    
    return `When('verifico que existen los elementos de ${categoryName}', () => {
    const elements = Object.keys(locators.${category} || {});
    cy.log(\`Verificando \${elements.length} elementos de ${categoryName}\`);
    
    elements.forEach(key => {
        const element = locators.${category}[key];
        if (element && element.primary) {
            cy.get(element.primary).should('exist');
        }
    });
});

Then('todos los elementos de ${categoryName} deben estar visibles', () => {
    cy.log('âœ… Elementos de ${categoryName} verificados');
});

Then('debo poder interactuar con {int} elementos de ${categoryName}', (cantidad) => {
    const elements = Object.keys(locators.${category} || {});
    expect(elements.length).to.equal(cantidad);
});`;
}).join('\n\n')}
`;

        const stepsPath = path.join(CONFIG.baseDir, CONFIG.stepsDir, 'comprehensiveSteps.js');
        await fs.writeFile(stepsPath, stepsContent);
        console.log(`ðŸ“„ Steps comprehensivos generados: ${path.relative(CONFIG.baseDir, stepsPath)}`);
        this.stats.stepsCreated++;
    }

    async generateSectionFeature(seccion, casos) {
        const seccionSlug = seccion.toLowerCase().replace(/[^a-z0-9]/g, '-');
        const featureContent = `# language: es
@${seccionSlug} @auto-generated
CaracterÃ­stica: ${seccion} - Casos de prueba automÃ¡ticos
  Como usuario del sistema
  Quiero ejecutar todos los casos de prueba de ${seccion}
  Para verificar que la funcionalidad estÃ¡ correcta

  Antecedentes:
    Dado que navego al sitio web
    Y espero que la pÃ¡gina estÃ© cargada

${casos.map((caso, index) => `  @caso-${index + 1}
  Escenario: ${caso.titulo}
${caso.pasos.map(paso => `    ${this.convertirPasoAGherkin(paso)}`).join('\n')}`).join('\n\n')}
`;

        const featurePath = path.join(CONFIG.baseDir, CONFIG.featuresDir, `${seccionSlug}-generated.feature`);
        await fs.writeFile(featurePath, featureContent);
        console.log(`ðŸ“„ Feature generado para ${seccion}: ${path.relative(CONFIG.baseDir, featurePath)}`);
        this.stats.featuresCreated++;
    }

    convertirPasoAGherkin(paso) {
        // Convertir pasos en texto libre a formato Gherkin
        const pasoLimpio = paso.trim();
        
        if (pasoLimpio.toLowerCase().includes('navegar') || pasoLimpio.toLowerCase().includes('ir a')) {
            return `Dado ${pasoLimpio}`;
        } else if (pasoLimpio.toLowerCase().includes('hacer click') || 
                   pasoLimpio.toLowerCase().includes('seleccionar') ||
                   pasoLimpio.toLowerCase().includes('escribir') ||
                   pasoLimpio.toLowerCase().includes('llenar')) {
            return `Cuando ${pasoLimpio}`;
        } else if (pasoLimpio.toLowerCase().includes('verificar') || 
                   pasoLimpio.toLowerCase().includes('validar') ||
                   pasoLimpio.toLowerCase().includes('debe')) {
            return `Entonces ${pasoLimpio}`;
        } else {
            return `Y ${pasoLimpio}`;
        }
    }

    async generateSectionSteps(seccion, casos) {
        const seccionSlug = seccion.toLowerCase().replace(/[^a-z0-9]/g, '-');
        const stepsContent = `import { Given, When, Then } from "@badeball/cypress-cucumber-preprocessor";

/**
 * ðŸŽ¯ STEPS PARA ${seccion.toUpperCase()}
 * Generado automÃ¡ticamente el: ${new Date().toISOString()}
 */

// Steps especÃ­ficos para ${seccion}
${casos.map((caso, index) => 
    caso.pasos.map(paso => this.generateStepDefinition(paso)).join('\n')
).join('\n\n')}
`;

        const stepsPath = path.join(CONFIG.baseDir, CONFIG.stepsDir, `${seccionSlug}GeneratedSteps.js`);
        await fs.writeFile(stepsPath, stepsContent);
        console.log(`ðŸ“„ Steps generados para ${seccion}: ${path.relative(CONFIG.baseDir, stepsPath)}`);
        this.stats.stepsCreated++;
    }

    generateStepDefinition(paso) {
        const pasoLimpio = paso.trim();
        const stepType = this.determineStepType(pasoLimpio);
        
        return `${stepType}('${pasoLimpio}', () => {
    cy.log('ðŸ“ Ejecutando: ${pasoLimpio}');
    // TODO: Implementar lÃ³gica especÃ­fica para este paso
    cy.log('âš ï¸ Paso pendiente de implementaciÃ³n');
});`;
    }

    determineStepType(paso) {
        const pasoLower = paso.toLowerCase();
        if (pasoLower.includes('navegar') || pasoLower.includes('ir a')) {
            return 'Given';
        } else if (pasoLower.includes('hacer click') || pasoLower.includes('seleccionar') || pasoLower.includes('escribir')) {
            return 'When';
        } else if (pasoLower.includes('verificar') || pasoLower.includes('validar') || pasoLower.includes('debe')) {
            return 'Then';
        } else {
            return 'And';
        }
    }

    async generateSectionPageObject(seccion, casos) {
        const seccionSlug = seccion.toLowerCase().replace(/[^a-z0-9]/g, '-');
        const className = seccion.replace(/[^a-zA-Z0-9]/g, '') + 'GeneratedPage';
        
        const pageObjectContent = `/**
 * ðŸŽ¯ PAGE OBJECT PARA ${seccion.toUpperCase()}
 * Generado automÃ¡ticamente el: ${new Date().toISOString()}
 */

const locators = require("./locators/AutoGeneratedLocators.json");

class ${className} {
    
    constructor() {
        this.locators = locators;
    }
    
    // MÃ©todos generados basados en casos de prueba
${casos.map((caso, index) => this.generatePageObjectMethods(caso, index)).join('\n\n')}
    
    // MÃ©todos de utilidad
    verificarElementoVisible(selector) {
        return cy.get(selector).should('be.visible');
    }
    
    hacerClick(selector) {
        return cy.get(selector).click();
    }
    
    escribirTexto(selector, texto) {
        return cy.get(selector).clear().type(texto);
    }
}

module.exports = ${className};
`;

        const pageObjectPath = path.join(CONFIG.baseDir, CONFIG.pagesDir, `${className}.js`);
        await fs.writeFile(pageObjectPath, pageObjectContent);
        console.log(`ðŸ“„ Page Object generado para ${seccion}: ${path.relative(CONFIG.baseDir, pageObjectPath)}`);
        this.stats.pageObjectsCreated++;
    }

    generatePageObjectMethods(caso, index) {
        const methodName = `ejecutarCaso${index + 1}`;
        return `    ${methodName}() {
        // ${caso.titulo}
        cy.log('ðŸŽ¯ Ejecutando: ${caso.titulo}');
        
        // Pasos del caso de prueba:
${caso.pasos.map(paso => `        // - ${paso}`).join('\n')}
        
        // TODO: Implementar lÃ³gica especÃ­fica
        cy.log('âš ï¸ MÃ©todo pendiente de implementaciÃ³n');
        
        return this;
    }`;
    }

    async generateMasterFeature(casosData) {
        const featureContent = `# language: es
@master @auto-generated
CaracterÃ­stica: Suite completa de casos de prueba automÃ¡ticos
  Como usuario del sistema
  Quiero ejecutar todos los casos de prueba disponibles
  Para verificar que toda la aplicaciÃ³n funciona correctamente

  Antecedentes:
    Dado que navego al sitio web
    Y espero que la pÃ¡gina estÃ© cargada

${Object.entries(casosData).map(([seccion, casos]) => `  @${seccion.toLowerCase().replace(/[^a-z0-9]/g, '-')}
  Escenario: Verificar secciÃ³n ${seccion}
    Cuando ejecuto todos los casos de prueba de "${seccion}"
    Entonces todos los casos de "${seccion}" deben pasar exitosamente
    Y debo tener ${casos.length} casos verificados`).join('\n\n')}

  @comprehensive
  Escenario: EjecuciÃ³n completa de todas las secciones
    Cuando ejecuto todos los casos de prueba disponibles
    Entonces todas las secciones deben pasar exitosamente
    Y debo tener un reporte completo de ejecuciÃ³n
`;

        const featurePath = path.join(CONFIG.baseDir, CONFIG.featuresDir, 'master-test-suite.feature');
        await fs.writeFile(featurePath, featureContent);
        console.log(`ðŸ“„ Feature maestro generado: ${path.relative(CONFIG.baseDir, featurePath)}`);
        this.stats.featuresCreated++;
    }

    // ========================================================================
    // CORREGIR IMPORTS Y REFERENCIAS
    // ========================================================================
    async fixImportsAndReferences() {
        console.log('\nðŸ”§ Corrigiendo imports y referencias...');
        
        // AquÃ­ se pueden agregar correcciones especÃ­ficas
        // Por ahora solo registramos que se ejecutÃ³
        console.log('   âœ… Imports verificados');
    }

    // ========================================================================
    // VALIDAR ARCHIVOS GENERADOS
    // ========================================================================
    async validateGeneratedFiles() {
        console.log('\nâœ… Validando archivos generados...');
        
        const filesToValidate = [
            path.join(CONFIG.baseDir, CONFIG.locatorsDir, CONFIG.outputFile),
            path.join(CONFIG.baseDir, CONFIG.locatorsDir, CONFIG.usageExampleFile),
            path.join(CONFIG.baseDir, CONFIG.featuresDir, 'auto-generated-scraper.feature'),
            path.join(CONFIG.baseDir, CONFIG.stepsDir, 'autoGeneratedScraperSteps.js'),
            path.join(CONFIG.baseDir, CONFIG.pagesDir, 'AutoGeneratedScraperPage.js')
        ];
        
        for (const filePath of filesToValidate) {
            try {
                await fs.access(filePath);
                const stats = await fs.stat(filePath);
                console.log(`   âœ… ${path.relative(CONFIG.baseDir, filePath)} (${stats.size} bytes)`);
            } catch (error) {
                console.log(`   âŒ ${path.relative(CONFIG.baseDir, filePath)} - No encontrado`);
                this.stats.errorsFound++;
            }
        }
    }

    // ========================================================================
    // GENERAR REPORTE FINAL
    // ========================================================================
    async generateFinalReport() {
        console.log('\nðŸ“Š Generando reporte final...');
        
        this.stats.endTime = new Date();
        this.stats.processingTime = this.stats.endTime - this.stats.startTime;
        
        const report = {
            ...this.stats,
            processingTimeMs: this.stats.processingTime,
            processingTimeFormatted: this.formatDuration(this.stats.processingTime),
            locatorStats: this.generatedLocators.metadata.processingStats,
            generatedFiles: {
                locators: CONFIG.outputFile,
                usageExample: CONFIG.usageExampleFile,
                feature: 'auto-generated-scraper.feature',
                steps: 'autoGeneratedScraperSteps.js',
                pageObject: 'AutoGeneratedScraperPage.js'
            }
        };
        
        const reportPath = path.join(CONFIG.baseDir, 'scripts', CONFIG.reportFile);
        await fs.writeFile(reportPath, JSON.stringify(report, null, 2));
        
        // Mostrar resumen en consola
        console.log('\nðŸ“‹ RESUMEN DEL PROCESAMIENTO:');
        console.log(`   â±ï¸ Tiempo total: ${report.processingTimeFormatted}`);
        console.log(`   ðŸ“ Archivos procesados: ${this.stats.filesProcessed}`);
        console.log(`   ðŸ“ Locators generados: ${this.stats.locatorsGenerated}`);
        console.log(`   ðŸ—ï¸ Features creados: ${this.stats.featuresCreated}`);
        console.log(`   ðŸ“„ Steps creados: ${this.stats.stepsCreated}`);
        console.log(`   ðŸ›ï¸ Page Objects creados: ${this.stats.pageObjectsCreated}`);
        console.log(`   âŒ Errores encontrados: ${this.stats.errorsFound}`);
        console.log(`   ðŸ“Š Reporte guardado en: ${path.relative(CONFIG.baseDir, reportPath)}`);
    }

    formatDuration(ms) {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        
        if (minutes > 0) {
            return `${minutes}m ${remainingSeconds}s`;
        }
        return `${remainingSeconds}s`;
    }
}

// ============================================================================
// FUNCIÃ“N PRINCIPAL PARA EJECUTAR EL SCRIPT
// ============================================================================
async function main() {
    try {
        const processor = new UnifiedScraperProcessor();
        await processor.processAll();
        
        console.log('\nðŸŽ‰ Â¡PROCESAMIENTO UNIFICADO COMPLETADO EXITOSAMENTE!');
        process.exit(0);
        
    } catch (error) {
        console.error('\nâŒ ERROR EN EL PROCESAMIENTO UNIFICADO:');
        console.error(error.message);
        console.error(error.stack);
        process.exit(1);
    }
}

// Ejecutar si se llama directamente
if (require.main === module) {
    main();
}

module.exports = { UnifiedScraperProcessor, CONFIG }; 