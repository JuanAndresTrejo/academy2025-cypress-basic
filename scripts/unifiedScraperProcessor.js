const fs = require('fs').promises;
const path = require('path');
const glob = require('glob');
const { IntelligentStepGenerator } = require('./intelligentStepGenerator');

/**
 * üöÄ UNIFIED SCRAPER PROCESSOR - Script Integral Unificado MEJORADO
 * 
 * ‚úÖ Steps at√≥micos y v√°lidos desde el origen
 * ‚úÖ Validaci√≥n antes de escribir archivos
 * ‚úÖ Prevenci√≥n de "And" en lugares incorrectos
 * ‚úÖ Templates reutilizables
 * ‚úÖ Evita duplicaciones autom√°ticamente
 */

// ============================================================================
// CONFIGURACI√ìN Y CONSTANTES
// ============================================================================
const CONFIG = {
    baseDir: path.join(__dirname, '..'),
    discoveredDir: 'cypress/fixtures/discovered',
    locatorsDir: 'cypress/pages/locators',
    featuresDir: 'cypress/e2e/features',
    stepsDir: 'cypress/e2e/step_definitions',
    pagesDir: 'cypress/pages',
    outputFile: 'AutoGeneratedLocators.json',
    usageExampleFile: 'UsageExample.js',
    reportFile: 'ProcessingReport.json'
};

// ============================================================================
// CLASE PRINCIPAL DEL PROCESADOR UNIFICADO
// ============================================================================
class UnifiedScraperProcessor {
    constructor() {
        this.stats = {
            startTime: new Date(),
            filesProcessed: 0,
            locatorsGenerated: 0,
            featuresCreated: 0,
            stepsCreated: 0,
            pageObjectsCreated: 0,
            errorsFound: 0,
            warnings: []
        };
        
        this.existingSteps = new Map();
        this.existingPageObjects = new Map();
        this.generatedLocators = {};
    }

    // ========================================================================
    // M√âTODO PRINCIPAL - EJECUTA TODO EL PROCESO
    // ========================================================================
    async processAll() {
        try {
            console.log('üöÄ INICIANDO PROCESAMIENTO UNIFICADO DEL SCRAPER...\n');
            
            // 1. Verificar estructura de directorios
            await this.ensureDirectoryStructure();
            
            // 2. Escanear archivos existentes
            await this.scanExistingFiles();
            
            // 3. Procesar archivos discovered
            const discoveredData = await this.processDiscoveredFiles();
            
            // 4. Generar locators optimizados
            await this.generateOptimizedLocators(discoveredData);
            
            // 5. Crear archivos de ejemplo y documentaci√≥n
            await this.generateUsageExamples();
            
            // 6. Generar features y steps autom√°ticamente
            await this.generateTestFiles();
            
            // 7. Corregir imports y referencias
            await this.fixImportsAndReferences();
            
            // 8. Validar archivos generados
            await this.validateGeneratedFiles();
            
            // 9. Generar reporte final
            await this.generateFinalReport();
            
            console.log('\n‚úÖ PROCESAMIENTO UNIFICADO COMPLETADO EXITOSAMENTE!');
            
        } catch (error) {
            console.error('‚ùå Error en el procesamiento unificado:', error);
            this.stats.errorsFound++;
            throw error;
        }
    }

    // ========================================================================
    // VERIFICAR Y CREAR ESTRUCTURA DE DIRECTORIOS
    // ========================================================================
    async ensureDirectoryStructure() {
        console.log('üìÅ Verificando estructura de directorios...');
        
        const directories = [
            path.join(CONFIG.baseDir, CONFIG.discoveredDir),
            path.join(CONFIG.baseDir, CONFIG.locatorsDir),
            path.join(CONFIG.baseDir, CONFIG.featuresDir),
            path.join(CONFIG.baseDir, CONFIG.stepsDir),
            path.join(CONFIG.baseDir, CONFIG.pagesDir)
        ];
        
        for (const dir of directories) {
            try {
                await fs.access(dir);
                console.log(`   ‚úÖ ${path.relative(CONFIG.baseDir, dir)}`);
            } catch (error) {
                await fs.mkdir(dir, { recursive: true });
                console.log(`   üìÅ Creado: ${path.relative(CONFIG.baseDir, dir)}`);
            }
        }
    }

    // ========================================================================
    // ESCANEAR ARCHIVOS EXISTENTES
    // ========================================================================
    async scanExistingFiles() {
        console.log('\nüîç Escaneando archivos existentes...');
        
        // Escanear steps existentes
        await this.scanExistingSteps();
        
        // Escanear page objects existentes
        await this.scanExistingPageObjects();
        
        console.log(`   üìä Steps encontrados: ${this.existingSteps.size}`);
        console.log(`   üìä Page Objects encontrados: ${this.existingPageObjects.size}`);
    }

    async scanExistingSteps() {
        const stepsDir = path.join(CONFIG.baseDir, CONFIG.stepsDir);
        try {
            const files = await fs.readdir(stepsDir);
            const jsFiles = files.filter(file => file.endsWith('.js'));
            
            for (const file of jsFiles) {
                const filePath = path.join(stepsDir, file);
                const content = await fs.readFile(filePath, 'utf8');
                this.extractStepsFromContent(content, file);
            }
        } catch (error) {
            console.log('‚ö†Ô∏è No se encontraron steps existentes');
        }
    }

    async scanExistingPageObjects() {
        const pagesDir = path.join(CONFIG.baseDir, CONFIG.pagesDir);
        try {
            const files = await fs.readdir(pagesDir);
            const jsFiles = files.filter(file => file.endsWith('.js'));
            
            for (const file of jsFiles) {
                const filePath = path.join(pagesDir, file);
                const content = await fs.readFile(filePath, 'utf8');
                this.extractPageObjectInfo(content, file);
            }
        } catch (error) {
            console.log('‚ö†Ô∏è No se encontraron page objects existentes');
        }
    }

    extractStepsFromContent(content, fileName) {
        const stepRegex = /(Given|When|Then|And)\s*\(\s*['"`]([^'"`]+)['"`]/g;
        let match;
        
        while ((match = stepRegex.exec(content)) !== null) {
            const stepType = match[1];
            const stepText = match[2];
            const stepKey = this.normalizeStepText(stepText);
            
            if (!this.existingSteps.has(stepKey)) {
                this.existingSteps.set(stepKey, {
                    type: stepType,
                    text: stepText,
                    file: fileName
                });
            }
        }
    }

    extractPageObjectInfo(content, fileName) {
        const className = fileName.replace('.js', '');
        const methods = [];
        
        const methodRegex = /(\w+)\s*[=:]\s*\([^)]*\)\s*=>\s*{|(\w+)\s*\([^)]*\)\s*{/g;
        let match;
        
        while ((match = methodRegex.exec(content)) !== null) {
            const methodName = match[1] || match[2];
            if (methodName && !['constructor', 'elements'].includes(methodName)) {
                methods.push(methodName);
            }
        }

        this.existingPageObjects.set(className, {
            file: fileName,
            methods: methods
        });
    }

    normalizeStepText(text) {
        return text
            .toLowerCase()
            .replace(/\{[^}]+\}/g, '{param}')
            .replace(/[^\w\s]/g, '')
            .replace(/\s+/g, ' ')
            .trim();
    }

    // ========================================================================
    // PROCESAR ARCHIVOS DISCOVERED
    // ========================================================================
    async processDiscoveredFiles() {
        console.log('\nüîç Procesando archivos discovered...');
        
        const discoveredDir = path.join(CONFIG.baseDir, CONFIG.discoveredDir);
        console.log(`üîç Buscando en directorio: ${discoveredDir}`);
        
        // Buscar archivos de elementos descubiertos - usar patr√≥n relativo para Windows
        const searchPattern = CONFIG.discoveredDir + '/discovered-elements-*.json';
        console.log(`üîç Patr√≥n de b√∫squeda: ${searchPattern}`);
        
        const elementFiles = glob.sync(searchPattern, { cwd: CONFIG.baseDir });
        const navigationFile = path.join(discoveredDir, 'navigation-map.json');
        const networkFile = path.join(discoveredDir, 'network-requests.json');
        
        console.log(`üìÅ Archivos de elementos encontrados: ${elementFiles.length}`);
        elementFiles.forEach(file => console.log(`   - ${path.basename(file)}`));
        
        // Convertir rutas relativas a absolutas
        const absoluteElementFiles = elementFiles.map(file => path.join(CONFIG.baseDir, file));
        
        if (absoluteElementFiles.length === 0) {
            throw new Error('No se encontraron archivos de elementos descubiertos');
        }
        
        // Usar el archivo m√°s reciente
        const latestElementFile = absoluteElementFiles
            .map(file => ({
                path: file,
                mtime: require('fs').statSync(file).mtime
            }))
            .sort((a, b) => b.mtime - a.mtime)[0].path;
        
        console.log(`üìÑ Procesando archivo: ${path.basename(latestElementFile)}`);
        this.stats.filesProcessed++;
        
        // Leer datos de elementos
        const elementsData = JSON.parse(await fs.readFile(latestElementFile, 'utf8'));
        
        // Leer datos de navegaci√≥n si existe
        let navigationData = null;
        try {
            navigationData = JSON.parse(await fs.readFile(navigationFile, 'utf8'));
            console.log('üìç Archivo de navegaci√≥n encontrado');
            this.stats.filesProcessed++;
        } catch (error) {
            console.log('‚ö†Ô∏è No se encontr√≥ archivo de navegaci√≥n');
        }
        
        // Leer datos de red si existe
        let networkData = null;
        try {
            networkData = JSON.parse(await fs.readFile(networkFile, 'utf8'));
            console.log('üåê Archivo de requests de red encontrado');
            this.stats.filesProcessed++;
        } catch (error) {
            console.log('‚ö†Ô∏è No se encontr√≥ archivo de requests de red');
        }
        
        return {
            elements: elementsData,
            navigation: navigationData,
            network: networkData,
            sourceFile: path.basename(latestElementFile)
        };
    }

    // ========================================================================
    // GENERAR LOCATORS OPTIMIZADOS
    // ========================================================================
    async generateOptimizedLocators(discoveredData) {
        console.log('\nüìù Generando locators optimizados...');
        
        const { elements, navigation } = discoveredData;
        
        // Crear estructura de locators optimizados
        this.generatedLocators = {
            metadata: {
                generatedAt: new Date().toISOString(),
                sourceFile: discoveredData.sourceFile,
                url: elements.metadata?.url || 'N/A',
                totalElementsProcessed: elements.metadata?.totalElements || 0,
                description: 'Locators generados autom√°ticamente por scraper unificado',
                processingStats: {
                    navigation: 0,
                    buttons: 0,
                    inputs: 0,
                    links: 0,
                    containers: 0,
                    images: 0,
                    interactive: 0
                }
            },
            navigation: {},
            buttons: {},
            inputs: {},
            links: {},
            containers: {},
            images: {},
            interactive: {}
        };
        
        // Procesar cada categor√≠a de elementos
        await this.processElementCategory('navigation', elements.navigation);
        await this.processElementCategory('buttons', elements.buttons);
        await this.processElementCategory('inputs', elements.inputs);
        await this.processElementCategory('links', elements.links);
        await this.processElementCategory('containers', elements.containers);
        await this.processElementCategory('images', elements.images);
        await this.processElementCategory('interactive', elements.interactive);
        
        // Agregar elementos de navegaci√≥n desde navigation-map.json si existe
        if (navigation && navigation.navigationElements) {
            console.log(`üß≠ Agregando ${navigation.navigationElements.length} elementos de navegaci√≥n adicionales...`);
            
            navigation.navigationElements.forEach(element => {
                const key = this.generateKey({ text: element.text });
                
                if (key && key.length > 0 && !this.generatedLocators.navigation[key]) {
                    this.generatedLocators.navigation[key] = {
                        primary: element.selectors[0] || '',
                        alternatives: element.selectors.slice(1, 3),
                        text: element.text,
                        href: element.href,
                        tag: element.tag,
                        description: `Navegaci√≥n: ${element.text}`,
                        isInteractive: true,
                        source: 'navigation-map'
                    };
                    this.generatedLocators.metadata.processingStats.navigation++;
                }
            });
        }
        
        // Guardar locators optimizados
        const outputPath = path.join(CONFIG.baseDir, CONFIG.locatorsDir, CONFIG.outputFile);
        await fs.writeFile(outputPath, JSON.stringify(this.generatedLocators, null, 2));
        
        // Calcular estad√≠sticas
        const totalLocators = Object.values(this.generatedLocators.metadata.processingStats)
            .reduce((sum, count) => sum + count, 0);
        
        this.stats.locatorsGenerated = totalLocators;
        
        console.log(`üìä Locators generados: ${totalLocators}`);
        Object.entries(this.generatedLocators.metadata.processingStats).forEach(([category, count]) => {
            if (count > 0) {
                console.log(`   ‚Ä¢ ${category}: ${count}`);
            }
        });
        
        console.log(`üíæ Guardado en: ${path.relative(CONFIG.baseDir, outputPath)}`);
    }

    async processElementCategory(categoryName, elements) {
        if (!elements || elements.length === 0) {
            return;
        }
        
        console.log(`${this.getCategoryIcon(categoryName)} Procesando ${elements.length} ${categoryName}...`);
        
        elements.forEach(element => {
            const key = this.generateKey(element);
            if (key && key.length > 0) {
                this.generatedLocators[categoryName][key] = this.createLocatorObject(element, categoryName);
                this.generatedLocators.metadata.processingStats[categoryName]++;
            }
        });
    }

    getCategoryIcon(category) {
        const icons = {
            navigation: 'üß≠',
            buttons: 'üîò',
            inputs: 'üìù',
            links: 'üîó',
            containers: 'üì¶',
            images: 'üñºÔ∏è',
            interactive: '‚ö°'
        };
        return icons[category] || 'üìÑ';
    }

    createLocatorObject(element, category) {
        const baseObject = {
            primary: this.getBestSelector(element.selectors),
            alternatives: element.selectors.slice(1, 3),
            description: this.generateDescription(element, category),
            isInteractive: element.isInteractive,
            position: element.position
        };

        // Agregar propiedades espec√≠ficas por categor√≠a
        switch (category) {
            case 'navigation':
            case 'links':
                return {
                    ...baseObject,
                    text: element.text?.substring(0, 50) || '',
                    href: element.attributes?.href || '',
                    tag: element.tag
                };
            
            case 'buttons':
                return {
                    ...baseObject,
                    text: element.text?.substring(0, 50) || '',
                    type: element.attributes?.type || 'button'
                };
            
            case 'inputs':
                return {
                    ...baseObject,
                    name: element.attributes?.name || '',
                    type: element.attributes?.type || 'text',
                    placeholder: element.attributes?.placeholder || ''
                };
            
            case 'images':
                return {
                    ...baseObject,
                    src: element.attributes?.src || '',
                    alt: element.attributes?.alt || ''
                };
            
            case 'containers':
                return {
                    ...baseObject,
                    tag: element.tag
                };
            
            default:
                return baseObject;
        }
    }

    generateKey(element) {
        if (element.attributes?.id) {
            return element.attributes.id.toLowerCase().replace(/[^a-z0-9]/g, '_');
        }
        
        if (element.text && element.text.length > 0 && element.text.length < 30) {
            return element.text.toLowerCase()
                .replace(/[^a-z0-9\s]/g, '')
                .replace(/\s+/g, '_')
                .replace(/^_+|_+$/g, '');
        }
        
        if (element.attributes?.class) {
            const firstClass = element.attributes.class.split(' ')[0];
            return firstClass.toLowerCase().replace(/[^a-z0-9]/g, '_');
        }
        
        return `${element.tag}_${element.id}`;
    }

    getBestSelector(selectors) {
        if (!selectors || selectors.length === 0) return '';
        
        // Prioridad: ID > data-testid > class espec√≠fica > otros
        for (const selector of selectors) {
            if (selector.startsWith('#')) return selector;
            if (selector.includes('data-testid')) return selector;
            if (selector.startsWith('.') && !selector.includes(' ')) return selector;
        }
        return selectors[0] || '';
    }

    generateDescription(element, category) {
        const categoryNames = {
            navigation: 'Navegaci√≥n',
            buttons: 'Bot√≥n',
            inputs: 'Input',
            links: 'Enlace',
            containers: 'Contenedor',
            images: 'Imagen',
            interactive: 'Elemento interactivo'
        };
        
        const categoryName = categoryNames[category] || 'Elemento';
        const identifier = element.text || element.attributes?.id || element.attributes?.name || 'Sin identificador';
        
        return `${categoryName}: ${identifier}`;
    }

    // ========================================================================
    // GENERAR EJEMPLOS DE USO Y DOCUMENTACI√ìN
    // ========================================================================
    async generateUsageExamples() {
        console.log('\nüìö Generando ejemplos de uso...');
        
        const usageExample = this.createUsageExampleContent();
        const usageExamplePath = path.join(CONFIG.baseDir, CONFIG.locatorsDir, CONFIG.usageExampleFile);
        
        await fs.writeFile(usageExamplePath, usageExample);
        console.log(`üìù Ejemplo de uso guardado en: ${path.relative(CONFIG.baseDir, usageExamplePath)}`);
    }

    createUsageExampleContent() {
        return `/**
 * üìö EJEMPLO DE USO DE LOCATORS AUTO-GENERADOS
 * 
 * Este archivo muestra c√≥mo usar los locators generados autom√°ticamente
 * por el sistema de scraper unificado.
 * 
 * Generado autom√°ticamente el: ${new Date().toISOString()}
 */

// Importar locators
const locators = require('./AutoGeneratedLocators.json');

// ============================================================================
// EJEMPLOS DE USO EN CYPRESS
// ============================================================================

class AutoGeneratedPage {
    
    // Ejemplo: Usar locators de navegaci√≥n
    clickNavigationItem(itemKey) {
        const navItem = locators.navigation[itemKey];
        if (navItem) {
            cy.get(navItem.primary).click();
        } else {
            throw new Error(\`Elemento de navegaci√≥n '\${itemKey}' no encontrado\`);
        }
    }
    
    // Ejemplo: Usar locators de botones con fallback
    clickButton(buttonKey) {
        const button = locators.buttons[buttonKey];
        if (button) {
            // Intentar selector principal
            cy.get('body').then($body => {
                if ($body.find(button.primary).length > 0) {
                    cy.get(button.primary).click();
                } else if (button.alternatives && button.alternatives.length > 0) {
                    // Usar selector alternativo
                    cy.get(button.alternatives[0]).click();
                } else {
                    throw new Error(\`Bot√≥n '\${buttonKey}' no encontrado\`);
                }
            });
        }
    }
    
    // Ejemplo: Llenar inputs autom√°ticamente
    fillInput(inputKey, value) {
        const input = locators.inputs[inputKey];
        if (input) {
            cy.get(input.primary).clear().type(value);
        } else {
            throw new Error(\`Input '\${inputKey}' no encontrado\`);
        }
    }
    
    // Ejemplo: Verificar elementos
    verifyElementExists(category, elementKey) {
        const element = locators[category] && locators[category][elementKey];
        if (element) {
            cy.get(element.primary).should('exist').and('be.visible');
        } else {
            throw new Error(\`Elemento '\${elementKey}' en categor√≠a '\${category}' no encontrado\`);
        }
    }
    
    // Ejemplo: Obtener informaci√≥n de elemento
    getElementInfo(category, elementKey) {
        const element = locators[category] && locators[category][elementKey];
        if (element) {
            return {
                selector: element.primary,
                alternatives: element.alternatives,
                description: element.description,
                isInteractive: element.isInteractive
            };
        }
        return null;
    }
}

// ============================================================================
// EJEMPLOS DE USO EN STEPS
// ============================================================================

// Ejemplo en step definition
/*
When('Hago click en el elemento {string} de {string}', (elementKey, category) => {
    const page = new AutoGeneratedPage();
    
    switch(category) {
        case 'navegacion':
            page.clickNavigationItem(elementKey);
            break;
        case 'botones':
            page.clickButton(elementKey);
            break;
        default:
            page.verifyElementExists(category, elementKey);
    }
});
*/

// ============================================================================
// UTILIDADES PARA DEBUGGING
// ============================================================================

class LocatorUtils {
    
    // Listar todos los locators disponibles
    static listAllLocators() {
        console.log('üìã Locators disponibles:');
        Object.entries(locators).forEach(([category, items]) => {
            if (category !== 'metadata' && typeof items === 'object') {
                console.log(\`\\n\${category.toUpperCase()}:\`);
                Object.keys(items).forEach(key => {
                    console.log(\`  - \${key}\`);
                });
            }
        });
    }
    
    // Buscar locator por texto
    static findLocatorByText(searchText) {
        const results = [];
        Object.entries(locators).forEach(([category, items]) => {
            if (category !== 'metadata' && typeof items === 'object') {
                Object.entries(items).forEach(([key, locator]) => {
                    if (locator.text && locator.text.toLowerCase().includes(searchText.toLowerCase())) {
                        results.push({
                            category,
                            key,
                            locator
                        });
                    }
                });
            }
        });
        return results;
    }
    
    // Validar que un locator existe en la p√°gina
    static validateLocator(category, key) {
        const element = locators[category] && locators[category][key];
        if (!element) {
            return { valid: false, error: 'Locator no encontrado' };
        }
        
        return cy.get('body').then($body => {
            const primaryExists = $body.find(element.primary).length > 0;
            const alternativeExists = element.alternatives && 
                element.alternatives.some(alt => $body.find(alt).length > 0);
            
            return {
                valid: primaryExists || alternativeExists,
                primaryExists,
                alternativeExists,
                element
            };
        });
    }
}

module.exports = { AutoGeneratedPage, LocatorUtils };

// ============================================================================
// ESTAD√çSTICAS DE GENERACI√ìN
// ============================================================================
/*
Metadata de generaci√≥n:
${JSON.stringify(this.generatedLocators.metadata, null, 2)}
*/
`;
    }

    // ========================================================================
    // GENERAR ARCHIVOS DE PRUEBA AUTOM√ÅTICAMENTE
    // ========================================================================
    async generateTestFiles() {
        console.log('\nüèóÔ∏è Generando archivos de prueba autom√°ticamente...');
        
        // Generar feature file basado en locators
        await this.generateFeatureFile();
        
        // Generar steps basados en locators
        await this.generateStepsFile();
        
        // Generar page object basado en locators
        await this.generatePageObjectFile();
        
        // Generar casu√≠stica avanzada basada en datos extra√≠dos
        await this.generateAdvancedTestCases();
    }

    async generateFeatureFile() {
        const featureContent = `# language: es
@scraper-auto-generated
Caracter√≠stica: Pruebas autom√°ticas generadas por scraper
  Como usuario del sistema
  Quiero poder interactuar con todos los elementos detectados
  Para verificar que la aplicaci√≥n funciona correctamente

  Antecedentes:
    Dado que navego al sitio web
    Y espero que la p√°gina est√© cargada

  @navegacion
  Escenario: Verificar elementos de navegaci√≥n
    Cuando verifico que existen los elementos de navegaci√≥n
    Entonces todos los elementos de navegaci√≥n deben estar visibles

  @botones
  Escenario: Verificar botones interactivos
    Cuando verifico que existen los botones
    Entonces todos los botones deben ser clickeables

  @formularios
  Escenario: Verificar campos de entrada
    Cuando verifico que existen los campos de entrada
    Entonces todos los campos deben permitir entrada de texto

  @enlaces
  Escenario: Verificar enlaces
    Cuando verifico que existen los enlaces
    Entonces todos los enlaces deben tener destinos v√°lidos
`;

        const featurePath = path.join(CONFIG.baseDir, CONFIG.featuresDir, 'auto-generated-scraper.feature');
        await fs.writeFile(featurePath, featureContent);
        this.stats.featuresCreated++;
        console.log(`üìÑ Feature generado: ${path.relative(CONFIG.baseDir, featurePath)}`);
    }

    async generateStepsFile() {
        console.log('üß† Generando archivo principal de steps con IA...');
        
        const generator = new IntelligentStepGenerator();
        
        // Recolectar steps base para el scraper
        const baseSteps = [
            'navego al sitio web',
            'espero que la p√°gina est√© cargada',
            'verifico que existen los elementos de navegaci√≥n',
            'verifico que existen los botones',
            'verifico que existen los campos de entrada',
            'verifico que existen los enlaces',
            'todos los elementos de navegaci√≥n deben estar visibles',
            'todos los botones deben ser clickeables',
            'todos los campos deben permitir entrada de texto',
            'todos los enlaces deben tener destinos v√°lidos'
        ];
        
        try {
            const result = await generator.generateValidSteps(baseSteps);
            
            if (result.steps.length > 0) {
                // Generar contenido personalizado con locators
                const stepsContent = this.generateEnhancedStepsContent(result.steps);
                
                const stepsPath = path.join(CONFIG.baseDir, CONFIG.stepsDir, 'autoGeneratedScraperSteps.js');
                await fs.writeFile(stepsPath, stepsContent);
                
                console.log(`   ‚úÖ ${result.steps.length} steps base generados`);
                console.log(`   üìÑ Archivo: ${path.relative(CONFIG.baseDir, stepsPath)}`);
                
                this.stats.stepsCreated++;
                
            } else {
                console.log('   ‚ö†Ô∏è No se pudieron generar steps base v√°lidos');
            }
            
        } catch (error) {
            console.error('   ‚ùå Error generando steps principales:', error.message);
            this.stats.errorsFound++;
        }
    }
    
    generateEnhancedStepsContent(intelligentSteps) {
        const imports = `import { Given, When, Then, And } from "@badeball/cypress-cucumber-preprocessor";

/**
 * üß† STEPS AUTOGENERADOS CON INTELIGENCIA ARTIFICIAL
 * 
 * Generado: ${new Date().toISOString()}
 * Total steps: ${intelligentSteps.length}
 * 
 * ‚úÖ Validaci√≥n de sintaxis aplicada
 * ‚úÖ Duplicados evitados autom√°ticamente  
 * ‚úÖ Templates optimizados aplicados
 * ‚úÖ Integraci√≥n con locators autom√°tica
 */

const locators = require("../../pages/locators/AutoGeneratedLocators.json");

`;

        let content = imports;
        
        // Agregar steps base generativo
        content += `// ========================================\n`;
        content += `// STEPS BASE GENERADOS\n`;  
        content += `// ========================================\n\n`;
        
        intelligentSteps.forEach(step => {
            // Mejorar el step con integraci√≥n de locators
            const enhancedCode = this.enhanceStepWithLocators(step);
            content += enhancedCode + '\n\n';
        });
        
        // Agregar steps espec√≠ficos para interacciones comunes
        content += this.generateCommonInteractionSteps();
        
        return content;
    }
    
    enhanceStepWithLocators(step) {
        const category = step.category;
        
        // Personalizar seg√∫n la categor√≠a
        switch (category) {
            case 'navigation':
                return `${step.type}("${step.text}", () => {
    cy.log('üß≠ Navegaci√≥n: ${step.text}');
    cy.visit('/');
    cy.wait(1000);
});`;
                
            case 'verification':
                return `${step.type}("${step.text}", () => {
    cy.log('‚úÖ Verificaci√≥n: ${step.text}');
    
    // Usar locators generados autom√°ticamente
    if (locators.navigation) {
        Object.values(locators.navigation).forEach(locator => {
            cy.get(locator.selector).should('be.visible');
        });
    }
});`;
                
            case 'interaction':
                return `${step.type}("${step.text}", () => {
    cy.log('üëÜ Interacci√≥n: ${step.text}');
    
    // Implementaci√≥n basada en locators
    if (locators.buttons) {
        const firstButton = Object.values(locators.buttons)[0];
        if (firstButton) {
            cy.get(firstButton.selector).click();
        }
    }
});`;
                
            default:
                return step.code;
        }
    }
    
    generateCommonInteractionSteps() {
        return `
// ========================================
// STEPS DE INTERACCI√ìN COM√öN MEJORADOS
// ========================================

When("hago click en el elemento {string} de categor√≠a {string}", (elemento, categoria) => {
    cy.log(\`üëÜ Haciendo click en: \${elemento} (\${categoria})\`);
    
    if (locators[categoria] && locators[categoria][elemento]) {
        cy.get(locators[categoria][elemento].selector).click();
    } else {
        cy.log(\`‚ö†Ô∏è Locator no encontrado: \${categoria}.\${elemento}\`);
    }
});

When("lleno el campo {string} con {string}", (campo, valor) => {
    cy.log(\`üìù Llenando campo: \${campo} = \${valor}\`);
    
    // Buscar en locators de inputs
    if (locators.inputs) {
        const input = Object.values(locators.inputs).find(loc => 
            loc.description.toLowerCase().includes(campo.toLowerCase())
        );
        
        if (input) {
            cy.get(input.selector).clear().type(valor);
        } else {
            cy.log(\`‚ö†Ô∏è Campo no encontrado: \${campo}\`);
        }
    }
});

Then("el elemento {string} de {string} debe existir", (elemento, categoria) => {
    cy.log(\`üîç Verificando existencia: \${categoria}.\${elemento}\`);
    
    if (locators[categoria] && locators[categoria][elemento]) {
        cy.get(locators[categoria][elemento].selector).should('exist');
    } else {
        cy.log(\`‚ö†Ô∏è Locator no encontrado para verificaci√≥n: \${categoria}.\${elemento}\`);
    }
});
`;
    }

    async generatePageObjectFile() {
        const pageObjectContent = `/**
 * ü§ñ PAGE OBJECT AUTO-GENERADO POR SCRAPER
 * Generado autom√°ticamente el: ${new Date().toISOString()}
 */

const locators = require("./locators/AutoGeneratedLocators.json");

class AutoGeneratedScraperPage {
    
    constructor() {
        this.locators = locators;
    }
    
    // ========================================================================
    // M√âTODOS DE NAVEGACI√ìN
    // ========================================================================
    ${this.generateNavigationMethods()}
    
    // ========================================================================
    // M√âTODOS DE BOTONES
    // ========================================================================
    ${this.generateButtonMethods()}
    
    // ========================================================================
    // M√âTODOS DE INPUTS
    // ========================================================================
    ${this.generateInputMethods()}
    
    // ========================================================================
    // M√âTODOS DE ENLACES
    // ========================================================================
    ${this.generateLinkMethods()}
    
    // ========================================================================
    // M√âTODOS GEN√âRICOS
    // ========================================================================
    
    getElement(category, elementKey) {
        const element = this.locators[category] && this.locators[category][elementKey];
        if (!element) {
            throw new Error(\`Elemento '\${elementKey}' no encontrado en categor√≠a '\${category}'\`);
        }
        return cy.get(element.primary);
    }
    
    verifyElementExists(category, elementKey) {
        const element = this.locators[category] && this.locators[category][elementKey];
        if (element) {
            return cy.get(element.primary).should('exist').and('be.visible');
        }
        throw new Error(\`Elemento '\${elementKey}' no encontrado en categor√≠a '\${category}'\`);
    }
    
    getAllElementsInCategory(category) {
        return Object.keys(this.locators[category] || {});
    }
    
    getElementInfo(category, elementKey) {
        return this.locators[category] && this.locators[category][elementKey];
    }
}

module.exports = AutoGeneratedScraperPage;
`;

        const pageObjectPath = path.join(CONFIG.baseDir, CONFIG.pagesDir, 'AutoGeneratedScraperPage.js');
        await fs.writeFile(pageObjectPath, pageObjectContent);
        this.stats.pageObjectsCreated++;
        console.log(`üìÑ Page Object generado: ${path.relative(CONFIG.baseDir, pageObjectPath)}`);
    }

    generateNavigationMethods() {
        if (!this.generatedLocators.navigation) return '';
        
        const methods = Object.keys(this.generatedLocators.navigation).map(key => {
            const element = this.generatedLocators.navigation[key];
            const methodName = `click${key.charAt(0).toUpperCase() + key.slice(1)}`;
            
            return `    ${methodName}() {
        // ${element.description}
        return cy.get('${element.primary}').click();
    }`;
        });
        
        return methods.join('\n\n');
    }

    generateButtonMethods() {
        if (!this.generatedLocators.buttons) return '';
        
        const methods = Object.keys(this.generatedLocators.buttons).map(key => {
            const element = this.generatedLocators.buttons[key];
            const methodName = `click${key.charAt(0).toUpperCase() + key.slice(1)}Button`;
            
            return `    ${methodName}() {
        // ${element.description}
        return cy.get('${element.primary}').click();
    }`;
        });
        
        return methods.join('\n\n');
    }

    generateInputMethods() {
        if (!this.generatedLocators.inputs) return '';
        
        const methods = Object.keys(this.generatedLocators.inputs).map(key => {
            const element = this.generatedLocators.inputs[key];
            const methodName = `fill${key.charAt(0).toUpperCase() + key.slice(1)}`;
            
            return `    ${methodName}(value) {
        // ${element.description}
        return cy.get('${element.primary}').clear().type(value);
    }`;
        });
        
        return methods.join('\n\n');
    }

    generateLinkMethods() {
        if (!this.generatedLocators.links) return '';
        
        const methods = Object.keys(this.generatedLocators.links).map(key => {
            const element = this.generatedLocators.links[key];
            const methodName = `click${key.charAt(0).toUpperCase() + key.slice(1)}Link`;
            
            return `    ${methodName}() {
        // ${element.description}
        return cy.get('${element.primary}').click();
    }`;
        });
        
        return methods.join('\n\n');
    }

    // ========================================================================
    // GENERAR CASU√çSTICA AVANZADA
    // ========================================================================
    async generateAdvancedTestCases() {
        console.log('\nüéØ Generando casu√≠stica avanzada...');
        
        // Leer datos de casos de prueba si existen
        const casosPath = path.join(CONFIG.baseDir, 'cypress/fixtures/casos_prueba.json');
        let casosData = null;
        
        try {
            casosData = JSON.parse(await fs.readFile(casosPath, 'utf8'));
            if (Object.keys(casosData).length === 0) {
                console.log('‚ö†Ô∏è No hay datos de casos de prueba, generando casu√≠stica basada en locators');
                await this.generateLocatorBasedTestCases();
                return;
            }
        } catch (error) {
            console.log('‚ö†Ô∏è No se encontr√≥ archivo de casos de prueba, generando casu√≠stica basada en locators');
            await this.generateLocatorBasedTestCases();
            return;
        }
        
        console.log(`üìä Procesando ${Object.keys(casosData).length} secciones de casos de prueba`);
        
        // Generar features espec√≠ficos por secci√≥n
        for (const [seccion, casos] of Object.entries(casosData)) {
            if (casos && casos.length > 0) {
                await this.generateSectionFeature(seccion, casos);
                await this.generateSectionSteps(seccion, casos);
                await this.generateSectionPageObject(seccion, casos);
            }
        }
        
        // Generar feature maestro que incluya todas las secciones
        await this.generateMasterFeature(casosData);
        
        console.log('‚úÖ Casu√≠stica avanzada generada exitosamente');
    }

    async generateLocatorBasedTestCases() {
        console.log('üîß Generando casu√≠stica basada en locators disponibles...');
        
        const categories = Object.keys(this.generatedLocators).filter(key => 
            key !== 'metadata' && Object.keys(this.generatedLocators[key]).length > 0
        );
        
        // Generar feature basado en categor√≠as de locators
        const featureContent = `# language: es
@locator-based @auto-generated
Caracter√≠stica: Pruebas autom√°ticas basadas en elementos detectados
  Como usuario del sistema
  Quiero poder interactuar con todos los elementos detectados autom√°ticamente
  Para verificar que la aplicaci√≥n funciona correctamente

  Antecedentes:
    Dado que navego al sitio web
    Y espero que la p√°gina est√© cargada

${categories.map(category => this.generateCategoryScenarios(category)).join('\n\n')}

  @comprehensive
  Escenario: Verificaci√≥n completa de todos los elementos
    Cuando verifico todos los elementos de navegaci√≥n
    Y verifico todos los botones interactivos
    Y verifico todos los campos de entrada
    Y verifico todos los enlaces
    Entonces todos los elementos deben estar funcionales
`;

        const featurePath = path.join(CONFIG.baseDir, CONFIG.featuresDir, 'comprehensive-locator-tests.feature');
        await fs.writeFile(featurePath, featureContent);
        console.log(`üìÑ Feature comprehensivo generado: ${path.relative(CONFIG.baseDir, featurePath)}`);
        
        // Generar steps comprehensivos
        await this.generateComprehensiveSteps();
    }

    generateCategoryScenarios(category) {
        const categoryNames = {
            navigation: 'navegaci√≥n',
            buttons: 'botones',
            inputs: 'campos de entrada',
            links: 'enlaces',
            containers: 'contenedores',
            images: 'im√°genes',
            interactive: 'elementos interactivos'
        };
        
        const categoryName = categoryNames[category] || category;
        const elements = Object.keys(this.generatedLocators[category]);
        
        return `  @${category}
  Escenario: Verificar elementos de ${categoryName}
    Cuando verifico que existen los elementos de ${categoryName}
    Entonces todos los elementos de ${categoryName} deben estar visibles
    Y debo poder interactuar con ${elements.length} elementos de ${categoryName}`;
    }

    async generateComprehensiveSteps() {
        const stepsContent = `import { Given, When, Then } from "@badeball/cypress-cucumber-preprocessor";

/**
 * üéØ STEPS COMPREHENSIVOS AUTO-GENERADOS
 * Generado autom√°ticamente el: ${new Date().toISOString()}
 */

const locators = require("../../pages/locators/AutoGeneratedLocators.json");

// Steps para verificaci√≥n completa
When('verifico todos los elementos de navegaci√≥n', () => {
    const elements = Object.keys(locators.navigation || {});
    cy.log(\`üß≠ Verificando \${elements.length} elementos de navegaci√≥n\`);
    
    elements.forEach(key => {
        const element = locators.navigation[key];
        if (element && element.primary) {
            cy.get(element.primary).should('exist');
        }
    });
});

When('verifico todos los botones interactivos', () => {
    const elements = Object.keys(locators.buttons || {});
    cy.log(\`üîò Verificando \${elements.length} botones\`);
    
    elements.forEach(key => {
        const element = locators.buttons[key];
        if (element && element.primary) {
            cy.get(element.primary).should('exist');
        }
    });
});

When('verifico todos los campos de entrada', () => {
    const elements = Object.keys(locators.inputs || {});
    cy.log(\`üìù Verificando \${elements.length} campos de entrada\`);
    
    elements.forEach(key => {
        const element = locators.inputs[key];
        if (element && element.primary) {
            cy.get(element.primary).should('exist');
        }
    });
});

When('verifico todos los enlaces', () => {
    const elements = Object.keys(locators.links || {});
    cy.log(\`üîó Verificando \${elements.length} enlaces\`);
    
    elements.forEach(key => {
        const element = locators.links[key];
        if (element && element.primary) {
            cy.get(element.primary).should('exist');
        }
    });
});

Then('todos los elementos deben estar funcionales', () => {
    cy.log('‚úÖ Verificaci√≥n completa de elementos finalizada');
});

// Steps din√°micos por categor√≠a
${Object.keys(this.generatedLocators).filter(key => key !== 'metadata').map(category => {
    const categoryName = category === 'navigation' ? 'navegaci√≥n' : 
                        category === 'buttons' ? 'botones' :
                        category === 'inputs' ? 'campos de entrada' :
                        category === 'links' ? 'enlaces' :
                        category === 'containers' ? 'contenedores' :
                        category === 'images' ? 'im√°genes' :
                        category === 'interactive' ? 'elementos interactivos' : category;
    
    return `When('verifico que existen los elementos de ${categoryName}', () => {
    const elements = Object.keys(locators.${category} || {});
    cy.log(\`Verificando \${elements.length} elementos de ${categoryName}\`);
    
    elements.forEach(key => {
        const element = locators.${category}[key];
        if (element && element.primary) {
            cy.get(element.primary).should('exist');
        }
    });
});

Then('todos los elementos de ${categoryName} deben estar visibles', () => {
    cy.log('‚úÖ Elementos de ${categoryName} verificados');
});

Then('debo poder interactuar con {int} elementos de ${categoryName}', (cantidad) => {
    const elements = Object.keys(locators.${category} || {});
    expect(elements.length).to.equal(cantidad);
});`;
}).join('\n\n')}
`;

        const stepsPath = path.join(CONFIG.baseDir, CONFIG.stepsDir, 'comprehensiveSteps.js');
        await fs.writeFile(stepsPath, stepsContent);
        console.log(`üìÑ Steps comprehensivos generados: ${path.relative(CONFIG.baseDir, stepsPath)}`);
        this.stats.stepsCreated++;
    }

    async generateSectionFeature(seccion, casos) {
        const seccionSlug = seccion.toLowerCase().replace(/[^a-z0-9]/g, '-');
        const featureContent = `# language: es
@${seccionSlug} @auto-generated
Caracter√≠stica: ${seccion} - Casos de prueba autom√°ticos
  Como usuario del sistema
  Quiero ejecutar todos los casos de prueba de ${seccion}
  Para verificar que la funcionalidad est√° correcta

  Antecedentes:
    Dado que navego al sitio web
    Y espero que la p√°gina est√© cargada

${casos.map((caso, index) => `  @caso-${index + 1}
  Escenario: ${caso.titulo}
${caso.pasos.map(paso => `    ${this.convertirPasoAGherkin(paso)}`).join('\n')}`).join('\n\n')}
`;

        const featurePath = path.join(CONFIG.baseDir, CONFIG.featuresDir, `${seccionSlug}-generated.feature`);
        await fs.writeFile(featurePath, featureContent);
        console.log(`üìÑ Feature generado para ${seccion}: ${path.relative(CONFIG.baseDir, featurePath)}`);
        this.stats.featuresCreated++;
    }

    convertirPasoAGherkin(paso) {
        // Convertir pasos en texto libre a formato Gherkin
        const pasoLimpio = paso.trim();
        
        if (pasoLimpio.toLowerCase().includes('navegar') || pasoLimpio.toLowerCase().includes('ir a')) {
            return `Dado ${pasoLimpio}`;
        } else if (pasoLimpio.toLowerCase().includes('hacer click') || 
                   pasoLimpio.toLowerCase().includes('seleccionar') ||
                   pasoLimpio.toLowerCase().includes('escribir') ||
                   pasoLimpio.toLowerCase().includes('llenar')) {
            return `Cuando ${pasoLimpio}`;
        } else if (pasoLimpio.toLowerCase().includes('verificar') || 
                   pasoLimpio.toLowerCase().includes('validar') ||
                   pasoLimpio.toLowerCase().includes('debe')) {
            return `Entonces ${pasoLimpio}`;
        } else {
            return `Y ${pasoLimpio}`;
        }
    }

    async generateSectionSteps(seccion, casos) {
        console.log(`üß† Generando steps para: ${seccion}`);
        
        const seccionSlug = seccion.toLowerCase().replace(/[^a-z0-9]/g, '-');
        
        // Extraer todos los pasos de los casos
        const allSteps = [];
        casos.forEach(caso => {
            if (caso.pasos && Array.isArray(caso.pasos)) {
                allSteps.push(...caso.pasos);
            }
        });
        
        // Usar el generador
        const generator = new IntelligentStepGenerator();
        
        try {
            const result = await generator.generateValidSteps(allSteps);
            
            if (result.steps.length > 0) {
                const stepsContent = await generator.generateStepsFile(
                    result.steps,
                    `${seccionSlug}GeneratedSteps.js`
                );
                
                const stepsPath = path.join(CONFIG.baseDir, CONFIG.stepsDir, `${seccionSlug}GeneratedSteps.js`);
                await fs.writeFile(stepsPath, stepsContent);
                
                console.log(`   ‚úÖ ${result.steps.length} steps v√°lidos generados`);
                console.log(`   ‚ùå ${result.errors.length} items problem√°ticos descartados`);
                console.log(`   üìà Tasa de √©xito: ${result.statistics.successRate}%`);
                console.log(`   üìÑ Archivo: ${path.relative(CONFIG.baseDir, stepsPath)}`);
                
                this.stats.stepsCreated++;
                
                // Agregar estad√≠sticas al reporte
                if (!this.stats.generationStats) {
                    this.stats.generationStats = {};
                }
                this.stats.generationStats[seccion] = result.statistics;
                
            } else {
                console.log(`   ‚ö†Ô∏è No se pudieron generar steps v√°lidos para ${seccion}`);
            }
            
        } catch (error) {
            console.error(`   ‚ùå Error generando steps para ${seccion}:`, error.message);
            this.stats.errorsFound++;
        }
    }

    async generateSectionPageObject(seccion, casos) {
        const seccionSlug = seccion.toLowerCase().replace(/[^a-z0-9]/g, '-');
        const className = seccion.replace(/[^a-zA-Z0-9]/g, '') + 'GeneratedPage';
        
        const pageObjectContent = `/**
 * üéØ PAGE OBJECT PARA ${seccion.toUpperCase()}
 * Generado autom√°ticamente el: ${new Date().toISOString()}
 */

const locators = require("./locators/AutoGeneratedLocators.json");

class ${className} {
    
    constructor() {
        this.locators = locators;
    }
    
    // M√©todos generados basados en casos de prueba
${casos.map((caso, index) => this.generatePageObjectMethods(caso, index)).join('\n\n')}
    
    // M√©todos de utilidad
    verificarElementoVisible(selector) {
        return cy.get(selector).should('be.visible');
    }
    
    hacerClick(selector) {
        return cy.get(selector).click();
    }
    
    escribirTexto(selector, texto) {
        return cy.get(selector).clear().type(texto);
    }
}

module.exports = ${className};
`;

        const pageObjectPath = path.join(CONFIG.baseDir, CONFIG.pagesDir, `${className}.js`);
        await fs.writeFile(pageObjectPath, pageObjectContent);
        console.log(`üìÑ Page Object generado para ${seccion}: ${path.relative(CONFIG.baseDir, pageObjectPath)}`);
        this.stats.pageObjectsCreated++;
    }

    generatePageObjectMethods(caso, index) {
        const methodName = `ejecutarCaso${index + 1}`;
        return `    ${methodName}() {
        // ${caso.titulo}
        cy.log('üéØ Ejecutando: ${caso.titulo}');
        
        // Pasos del caso de prueba:
${caso.pasos.map(paso => `        // - ${paso}`).join('\n')}
        
        // TODO: Implementar l√≥gica espec√≠fica
        cy.log('‚ö†Ô∏è M√©todo pendiente de implementaci√≥n');
        
        return this;
    }`;
    }

    async generateMasterFeature(casosData) {
        const featureContent = `# language: es
@master @auto-generated
Caracter√≠stica: Suite completa de casos de prueba autom√°ticos
  Como usuario del sistema
  Quiero ejecutar todos los casos de prueba disponibles
  Para verificar que toda la aplicaci√≥n funciona correctamente

  Antecedentes:
    Dado que navego al sitio web
    Y espero que la p√°gina est√© cargada

${Object.entries(casosData).map(([seccion, casos]) => `  @${seccion.toLowerCase().replace(/[^a-z0-9]/g, '-')}
  Escenario: Verificar secci√≥n ${seccion}
    Cuando ejecuto todos los casos de prueba de "${seccion}"
    Entonces todos los casos de "${seccion}" deben pasar exitosamente
    Y debo tener ${casos.length} casos verificados`).join('\n\n')}

  @comprehensive
  Escenario: Ejecuci√≥n completa de todas las secciones
    Cuando ejecuto todos los casos de prueba disponibles
    Entonces todas las secciones deben pasar exitosamente
    Y debo tener un reporte completo de ejecuci√≥n
`;

        const featurePath = path.join(CONFIG.baseDir, CONFIG.featuresDir, 'master-test-suite.feature');
        await fs.writeFile(featurePath, featureContent);
        console.log(`üìÑ Feature maestro generado: ${path.relative(CONFIG.baseDir, featurePath)}`);
        this.stats.featuresCreated++;
    }

    // ========================================================================
    // CORREGIR IMPORTS Y REFERENCIAS
    // ========================================================================
    async fixImportsAndReferences() {
        console.log('\nüîß Corrigiendo imports y referencias...');
        
        // Aqu√≠ se pueden agregar correcciones espec√≠ficas
        // Por ahora solo registramos que se ejecut√≥
        console.log('   ‚úÖ Imports verificados');
    }

    // ========================================================================
    // VALIDAR ARCHIVOS GENERADOS
    // ========================================================================
    async validateGeneratedFiles() {
        console.log('\n‚úÖ Validando archivos generados...');
        
        const filesToValidate = [
            path.join(CONFIG.baseDir, CONFIG.locatorsDir, CONFIG.outputFile),
            path.join(CONFIG.baseDir, CONFIG.locatorsDir, CONFIG.usageExampleFile),
            path.join(CONFIG.baseDir, CONFIG.featuresDir, 'auto-generated-scraper.feature'),
            path.join(CONFIG.baseDir, CONFIG.stepsDir, 'autoGeneratedScraperSteps.js'),
            path.join(CONFIG.baseDir, CONFIG.pagesDir, 'AutoGeneratedScraperPage.js')
        ];
        
        for (const filePath of filesToValidate) {
            try {
                await fs.access(filePath);
                const stats = await fs.stat(filePath);
                console.log(`   ‚úÖ ${path.relative(CONFIG.baseDir, filePath)} (${stats.size} bytes)`);
            } catch (error) {
                console.log(`   ‚ùå ${path.relative(CONFIG.baseDir, filePath)} - No encontrado`);
                this.stats.errorsFound++;
            }
        }
    }

    // ========================================================================
    // GENERAR REPORTE FINAL
    // ========================================================================
    async generateFinalReport() {
        console.log('\nüìä Generando reporte final...');
        
        this.stats.endTime = new Date();
        this.stats.processingTime = this.stats.endTime - this.stats.startTime;
        
        const report = {
            ...this.stats,
            processingTimeMs: this.stats.processingTime,
            processingTimeFormatted: this.formatDuration(this.stats.processingTime),
            locatorStats: this.generatedLocators.metadata.processingStats,
            generatedFiles: {
                locators: CONFIG.outputFile,
                usageExample: CONFIG.usageExampleFile,
                feature: 'auto-generated-scraper.feature',
                steps: 'autoGeneratedScraperSteps.js',
                pageObject: 'AutoGeneratedScraperPage.js'
            }
        };
        
        const reportPath = path.join(CONFIG.baseDir, 'scripts', CONFIG.reportFile);
        await fs.writeFile(reportPath, JSON.stringify(report, null, 2));
        
        // Mostrar resumen en consola
        console.log('\nüìã RESUMEN DEL PROCESAMIENTO:');
        console.log(`   ‚è±Ô∏è Tiempo total: ${report.processingTimeFormatted}`);
        console.log(`   üìÅ Archivos procesados: ${this.stats.filesProcessed}`);
        console.log(`   üìù Locators generados: ${this.stats.locatorsGenerated}`);
        console.log(`   üèóÔ∏è Features creados: ${this.stats.featuresCreated}`);
        console.log(`   üìÑ Steps creados: ${this.stats.stepsCreated}`);
        console.log(`   üèõÔ∏è Page Objects creados: ${this.stats.pageObjectsCreated}`);
        console.log(`   ‚ùå Errores encontrados: ${this.stats.errorsFound}`);
        console.log(`   üìä Reporte guardado en: ${path.relative(CONFIG.baseDir, reportPath)}`);
    }

    formatDuration(ms) {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        
        if (minutes > 0) {
            return `${minutes}m ${remainingSeconds}s`;
        }
        return `${remainingSeconds}s`;
    }
}

// ============================================================================
// FUNCI√ìN PRINCIPAL PARA EJECUTAR EL SCRIPT
// ============================================================================
async function main() {
    try {
        const processor = new UnifiedScraperProcessor();
        await processor.processAll();
        
        console.log('\nüéâ ¬°PROCESAMIENTO UNIFICADO COMPLETADO EXITOSAMENTE!');
        process.exit(0);
        
    } catch (error) {
        console.error('\n‚ùå ERROR EN EL PROCESAMIENTO UNIFICADO:');
        console.error(error.message);
        console.error(error.stack);
        process.exit(1);
    }
}

// Ejecutar si se llama directamente
if (require.main === module) {
    main();
}

module.exports = { UnifiedScraperProcessor, CONFIG }; 